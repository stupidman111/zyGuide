
# TCP/IP网络模型与OSI网络模型
> ...


* TCP/IP分为哪几层？作用分别是？
	* 应用层：负责提供应用服务，如HTTP、FTP、DNS、SMTP等；
	* 传输层：负责端到端的传输，有TCP、UDP；
	* 网络层：负责网络包的封装、分片、路由、转发，有IP、ICMP、ARP；
	* 网络接口层：负载网络包在物理网络中的传输，如网络包的封帧、MAC寻址、差错检测、通过网卡传输网络帧等；
* OSI分为哪几层，作用分别是：
	* 应用层：给应用程序提供统一接口
	* 表示层：编码、解码
	* 会话层：建立、管理、终止实体之间的通话
	* 传输层：端到端的传输
	* 网络层：分片、寻址、路由
	* 数据链路层：封帧、MAC寻址
	* 物理层：物理网络中传输数据帧
* TCP/IP与OSI的对应关系：
	* TCP/IP的应用层--OSI的应用层、表示层、会话层
	* TCP/IP的传输层--OSI的传输层
	* TCP/IP的网络层--OSI的网络层
	* TCP/IP的网络接口层--OSI的数据链路层、物理层

# 键入网址到网页显示流程
> 涉及：HTTP、DNS、OS、TCP、IP、MAC、网卡、交换机、路由器等


* 浏览器解析URL，获取域名、访问路径等信息，生成HTTP请求信息
	* 
* 查DNS获取域名对应的IP地址信息
	* 域名解析流程（比如要获取www.server.com的IP地址）
		* 访问缓存；
		* 访问本地域名服务器；
		* 根据本地域名服务器保存的根域名服务器的地址`.`，访问根域名服务器；
		* 根据根域名服务器返回的顶级域名服务器的地址`.com`，访问顶级域名服务器；
		* 根据顶级域名服务器返回的权威域名服务器的地址`server.com`，访问权威域名服务器；
		* 权威域名服务器返回`server.com`的IP地址给本地域名服务器，本地域名服务器将地址返回给客户端；
* 封装HTTP消息
* 调用Socket库发送HTTP消息
* 封装成TCP
* 封装成IP
* 封装成MAC
* 由网卡驱动程序控制网卡发送二进制数据
* 交换机
* 路由器
* 到达目的服务器进行解封装


# Linux如何收发网络包
> 参考资料：
>  [Linux 网络包发送过程](https://mp.weixin.qq.com/s/wThfD9th9e_-YGHJJ3HXNQ)
>  [Linux 网络数据接收流程（TCP）- NAPI](https://wenfh2020.com/2021/12/29/kernel-tcp-receive/)
>  [Linux网络-数据包接收过程](https://blog.csdn.net/frank_jb/article/details/115841622)


> 从下图中可以看到：
> 	应用程序通过系统调用，来跟Socket层进行数据交互；
> 	Socket层下面就是传输层、网络层、网络接口层；
> 	最下面的一层，是网卡驱动程序和硬件网卡设备；
![](Linux网络协议栈.png)

* Linux接收网络包流程：
* Linux发送网络包流程：

> 在Linux中，全部的数据包都用一个结构体`sk_buff`来描述，对于每一种协议对应的数据包，只需要移动该结构体中`data`的指针即可；这样可以避免大量的数据拷贝的工作；


* 接收网络数据时，涉及几次内存拷贝操作？
* 发送网络数据时，涉及几次内存拷贝操作？


# HTTP

## HTTP基本概念
> HTTP----HyperText Transfer Protocol---`超文本-传输-协议`

### HTTP常见状态码
* `1XX`：表示传输流转状态，是一种中间状态；
* `2XX`：表示传输成功，具体地有：
	* `200 OK`：最常见的成功状态码，表示一切正常；
	* `204 No Content`：响应头没有body数据；
	* `206 Partial Content`：返回的HTTP消息是分块传输的；
* `3XX`：表示重定向，具体地有：
	* `301 Moved Permanently`：永久重定向，一般在响应头中使用Location指明重定向后的URL；
	* `302 Found`：临时重定向，一般在响应头中使用Location指明重定向后的URL；
	* `304 Not Modified`：走缓存；
* `4XX`：客户端报文错误，具体地有：
	* `400 Bad Request`：表示客户端请求报文有错误，服务端无法识别；
	* `403 Forbidden`：表示服务器禁止访问资源，并不是客户端请求出错；
	* `404 Not Fount`：表示客户端访问的资源不存在；
* `5XX`：服务器内部错误，具体地有：
	* `500 Internal Server Error`：服务器内部错误；
	* `501 Not Implemented`：访问的资源还没有实现；
	* `502 Bad Gateway`：代理或网关错误，服务器本身正常；
	* `503 Service Unavailable`：服务器忙；

### HTTP常见字段
> ...

* `Host`：访问的服务器域名；
* `Content-Length`：body部分长度；
* `Connection`：连接模式，长连接还是短连接，长连接为`Keep Alive`（与TCP Keep-Alive不是一个东西）；
* `Content-Type`：body部分的数据格式，如`text/html; Charset=utf-8`表示发生的是网页，编码是UTF-8；
* `Accept`：可以接受的数据格式，如`*/*`表示可接受任何形式的数据；
* `Content-Encoding`：数据的压缩方法，如`gzip`
* `Accept-Encoding`：可以接受的压缩方法，如`gzip, deflate`；


## GET与POST
### GET与POST的区别
> ...

* GET的语义：从服务器获取资源，参数一般在URL中，且是ASCII码形式的，浏览器对URL参数长度做了限制；
* POST的语义：根据请求体中的数据，对服务器进行一定的更改，URL中也可以携带参数，数据长度一般没有限制；
### 安全与幂等
> ...

* 安全：对服务器的操作不会改变服务器上的数据；
* 幂等：对服务器的多次请求，获得的结果是相同的；
* GET是否是安全且幂等的？
	* 从RFC规定上来看，GET是安全且幂等的，只用来从服务器获取资源；
	* 但实际也可以使用GET来修改资源，不过一般不这么做；
	* GET也可以携带body数据；
* POST是否是安全且幂等的？
	* 从RFC规定上来看，POST是非安全且非幂等的，会修改服务器数据；
	* 但实际也可以使用POST来获取资源，不过一般不这么做；
	* POST也可设置URL参数；
> HTTP都是明文传输的，不存在安全一说，但可以通过HTTPS对数据进行加密传输；

## HTTP缓存技术
> 为什么使用缓存技术？
> 	对于某些请求，多次得到的数据都是一样的，那么就可以把这对【请求-响应】的数据缓存在本地，下次就可以直接读取本地数据，从而提高性能。

### 强制缓存
> 强制缓存指的是只要浏览器判断缓存未过期，那么就直接使用缓存里的数据，决定是否使用缓存的主动性在浏览器这边。

可使用以下两个字段来实现：
* `Cache-Control`：一个相对时间，优先级更高
* `Expires`：一个绝对时间

流程：
* 当浏览器第一次访问服务器资源时，服务器返回的响应会在响应头字段中加上`Cache-Control`来设置一个过期时间；
* 下次浏览器对该资源再发起请求时，会先通过请求资源的时间与`Cache-Control`设置的时间进行计算，判断是否过期，没过期就走缓存，过期了就再向服务发起请求；
* 服务器响应会再次更新`Cache-Control`；
### 本地缓存
> 协商缓存指的是某些请求的响应结果状态码是`304-Not Modifed`，表示告知浏览器可以走本地缓存，这种方式是服务器与浏览器协商决定的。

两种实现方式：
* 第一种，可使用以下两个字段来实现：
	* 请求头部中的`If-Modified-Since`：
	* 响应头部中的`Last-Modified`：
* 第二种，


## HTTP特性
> HTTP常见版本：HTTP/1.1、HTTP/2.0、HTTP/3.0

> HTTPS就是在HTTP层与TCP层之间加了一个SSL/TLS安全传输层；
> HTTP/1.1与HTTP/2.0传输协议使用的是TCP协议，而HTTP/3.0使用的是UDP协议；

### HTTP/1.1的优点

* 简单：报文格式为`Header + Body`，头部数据为`Key-Value`格式；
* 灵活、易扩展：
* 应用广泛、跨平台：

### HTTP/1.1的缺点

* 无状态的缺点：
	* 好处：不需要额外记录状态信息；
	* 缺点：对于有关联性的请求会比较麻烦；（如登录->添加购物车->下单->结算->支付，由于无状态，每一次都需要对身份进行验证）
	* 解决：
		* `Cookie-Session技术`：请求达到服务器时，会针对该请求生成一个Session号，并存储部分信息（key-value），保存在服务器的Session中，同时在响应体中Cookie中加上Session号再返回响应给浏览器，浏览器将Cookie中的Session号保存到本地，下次对相同资源发起请求时，携带Session号到Cookie中发生给服务器，服务器通过请求中Cookie中的Session号访问本地Session取出信息进行验证。
		* `Redis技术`：
		* `JWT技术`：
* 明文传输、不安全：
	* 解决方案：引入SSL/TLS层；

### HTTP/1.1的性能

* 长连接：在`Connection-Type`状态中使用`Keep-Alive`字段保持连接；
* 管道网络传输：客户端可以连续发送多次请求，不需要等一个请求发出得到响应后再发送下一个请求，但服务器必须按请求的先后顺序进行处理；这种方式解决了请求的队头阻塞问题，但没有解决服务器响应的队头阻塞问题；且管道传输大部分时间不是默认开启的；
* 队头阻塞：当顺序发生的一个请求因为某种原因被阻塞了迟迟得不到响应，导致后续请求无法发出（这就是未开启管道网络传输的情况）

## HTTP与HTTPS

### HTTP与HTTPS区别
* HTTP使用明文传输，HTTPS使用加密传输
* HTTP建立连接只需要TCP三次握手，HTTPS建立连接需要TCP三次握手、SSL/TSL握手
* HTTP默认使用80端口，HTTPS模式使用443端口
* HTTPS需要向CA-证书权威机构来申请数字证书，来确保服务器身份可信

### HTTPS的特点
* HTTPS采用对称加密与非对称加密混合方式（混合加密）：
	* 对称加密：双方只使用一个密匙，密匙需要保密；
	* 非对称加密：使用两个密匙-公钥、私钥；公钥可以任意分发，而私钥则必须保密；
	* HTTPS通信建立过程中使用非对称加密方式交换`会话密匙`；
	* HTTPS通信过程中使用`会话密匙`以对称加密方式交换加密的明文数据；
	* 非对称加密使用方式：
		* 公钥：公开给所有人，任意分发；
		* 私钥：由服务端管理，不可泄漏；
		* 公钥和私钥可以双向加解密：
			* 公钥加密，私钥解密：目的是保证数据的安全性
			* 私钥加密，公钥解密：目的是保证数据来源的可靠性
* HTTPS使用摘要算法（哈希函数）+数字签名的方式保证数据内容不被篡改：
	* 先用摘要算法计算出内容的哈希值（指纹），哈希值是唯一的，无法通过哈希值推导出内容，然后将内容同哈希值一起发送；
	* 接收方也使用摘要算法对接收到的内容部分计算出一个哈希值，然后与接收到的哈希值进行比较，若相同，这数据内容是安全的，否则则不安全；
	* 这里的数字签名算法使用的就是私钥加密-公钥解密的一种实现方式：
		* 使用私钥（数字签名算法）对摘要算法计算出的内容的哈希值进行加密；
		* 使用公钥（数字签名算法）对所得到的哈希值进行解密；
	* 整体流程为：
		* 服务端对响应的内容使用摘要算法（哈希函数）进行计算得到哈希值；
		* 服务端使用私钥（数字签名算法）对哈希值进行加密；
		* 客户端使用摘要算法（哈希函数）对内容进行计算得到哈希值；
		* 客户端使用公钥（数字签名算法）对哈希值进行解密；
		* 客户端比对解密得到的哈希值与计算的得到的哈希值是否相同；
* HTTPS使用CA（数字证书认证机构）发布数字证书：
	* 服务器公钥需要放在数字证书中，且由数字证书认证机构来颁发；


* 整体流程：
	* 服务器将自己的公钥注册到CA；
	* CA通过自己的私钥，将服务器注册的公钥加密（数字签名）生成数字证书；
	* 客户端需要访问某个服务器时，会找CA要该服务器的数字证书（即公钥）；
	* CA颁发数字证书给客户端；
	* 客户端从浏览器或操作系统中取出CA的公钥（预置的）；
	* 客户端使用CA的公钥对数字证书进行解密（私钥加密，公钥解密，确定数据来源的可靠性）确认数字证书的可靠性，并得到服务器的公钥；
	* 客户端用获取到的公钥对数据进行加密发送给服务器；
	* 服务器通过自己的私钥对数据进行解密（公钥加密，私钥解密，确保数据内容的安全）
	* 需要注意，上面的过程是客户端与服务器建立连接的过程（使用非对称加密），这个交换的内容是`会话密匙`，当建立成功后，双方只需要通过会话密匙对数据进行加解密通信即可；

### HTTPS如何建立连接的？
> 先进行TCP三次握手建立连接，然后进行TLS四次握手

* TCP三次握手之后，进行TLS四次握手：
* 第一步，客户端发送ClientHello消息，其中包括：
	* 客户端支持的TLS协议版本；
	* 客户端生成的随机数（用于生成会话密匙的条件之一）---ClientRandom；
	* 客户端支持的密码套件列表，如RSA加密算法等；
* 第二步，服务器收到客户端ClientHello请求后，向客户端发送ServerHello响应，其中包括：
	* 确实TLS协议版本，如果浏览器不支持，则关闭加密通信；
	* 服务器生成的随机数（用于生成会话密匙的条件之一）---ServerRandom；
	* 确认密码套件列表，如RSA加密算法；
	* 服务器的数字证书；
* 第三步，客户端收到ServerHello响应后，根据自己本地存储的CA公钥，对数字证书进行解密，验证服务器公钥的真实性，取出服务器公钥，使用该公钥加密报文，发送以下报文给服务器，其中包括：
	* 一个随机数（用于生成会话密匙的条件之一）---pre master key；
	* 加密通信算法改变通知，表示随后的信息采用【会话密匙】进行加密通信；
	* 客户端握手结束通知；表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验；
* 第四步，服务器收到客户端的随机数pre master key，想客户端发送建立连接的最后通信：
	* 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信；
	* 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验；
> 上述三个用于生成会话密匙的条件，此时双方都已经持有，于是双方都可以使用这三个随机数，加上协商过程中商定的加密算法，比如RSA，生成【会话密匙】。

* 后续的通信都是要【会话密匙】进行对称加密通信；


> 以下内容来自《计算机网络-自顶向下方法》

* SSL使通信双方在SSL握手时就密码算法取得一致。
* 在握手阶段，双发彼此发送`不重数`，该数会用于生成会话密匙。

* SSL握手过程如下：
	1.客户端发送它所支持的密码算法的列表，以及一个`不重数`；
	2.服务端从客户端所支持的密码算法列表中选择一种对称算法、一种公钥算法、一种MAC算法，然后将服务端的证书、所选择的算法、一个`不重数`返回给客户端；
	3.客户端通过本地所存储的权威机构公钥解密证书获取服务端的公钥，生成一个`前主密钥PMS`，用服务端的公钥加密该前主密钥，并将加密的PMS发生给服务器；
	4.双方使用相同的密匙导出函数（该函数可能是SSL标准定义的）从PMS和两个不重数中计算出`主密匙MS`。然后该MS被切片，以生成两个密码和两个MAC密匙。之后，客户端和服务端之间发送的所有报文都被加密和鉴别；
	5.客户端发送所有握手报文的一个MAC；
	6.服务端发送所有握手报文的一个MAC；

> 5、6阶段的作用：验证握手是否被篡改：
> 	比如客户端发送所支持的密码算法列表时，中间服务器拦截了，并剔除掉加密强度高的算法，迫使服务器端只能选择加密强度低的算法。为了防止这种篡改，双方在最后将之前自己所发生的握手报文生成MAC供对方校验，验证双方所收到的报文是否被篡改过。

### HTTPS数据如何保证完整性？
> TLS在实现上分为：握手协议和记录协议两层；

* 握手协议就是上述TLS四次握手的过程；
* 记录协议负责保护数据，并验证器完整性和来源，对HTTP数据加密使用记录协议；
	* 首先，数据被分为若干较短的片段；
	* 对每个片段进行压缩；
	* 对经过压缩的片段加上哈希算法生成的MAC值，是为了保证数据完整性；
	* 对加了MAC值的压缩片段进行对称加密；
	* 经过加密的数据加上数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。

> 分片-->压缩-->加MAC值-->对称加密-->加上报头

### HTTPS一定安全可靠吗？
> 中间人服务器相关问题。

## HTTP/1.1、HTTP/2、HTTP/3
### HTTP/1.1相比HTTP/1.0
* 长连接：HTTP/1.1可使用长连接避免每次请求都需要TCP三次握手的尴尬；
* 支持管道网络传输：只要第一个请求发送出去了，不需要等待第一个请求的响应，就可发送后续的请求，解决的请求队头阻塞的问题，但是会导致响应队头阻塞的问题，因为服务器需要按照请求顺序做出响应；

* HTTP/1.1存在的性能瓶颈：
	* 请求/响应头部未经压缩就发送（body部分会压缩）
	* 服务端需要安装请求到达的顺序来响应
	* 请求只能由客户端主动发起，服务端来被动响应；

### HTTP/2做了什么优化？
> HTTP/2协议是基于HTTPS的。

HTTP/2的改进：
* 头部压缩
* 二进制格式
* 并发传输
* 服务器主动推送资源



### HTTP/3做了什么优化？
> HTTP下层的协议是基于UDP的QUIC协议。


# TCP

## TCP基本概念
### TCP头格式
* 16源端口号 + 16目的端口号
* 32序列号
* 32确认号
* 4首部长度 + 6保留位 + URG + ACK + PSH + RST + SYN + FIN + 16窗口大小
* 16校验和 + 16紧急指针
* 选项...
* 数据...
![](TCP报文格式.png)

> 各部分的作用：
* 源端口号、目的端口号：指明发送的端口、接收的端口。
* 序列号：建立连接时生成随机值作为序列号的初始值，之后每发送一次报文，就累加该报文的字节数大小。`用于解决网络包乱序问题`。
* 确认号：指下一次期待收到的数据的序列号，发送端收到该确认号即可认为该确认号之前的所有序列号的报文已经收到。`用于解决丢包问题`。
* 控制位：
	* ACK：该位为1时，表示确认应答，除最初建立连接时的第一个SYN包之外，其他包的改为必须设置为1；
	* RST：该位为1时，表示TCP连接出现异常必须强制断开连接；
	* SYN：该位为1时，表示发送的是建立连接报文；
	* FIN：该为为1时，表示发生的是断开连接报文；
### TCP的作用
> 由于IP层是不可靠的，它不保证网络包的交付、按序到达、完整性；
> TCP层是工作在传输层的提供可靠传输服务的协议，能够确保接收端介绍到的网络包是完整、按序的。

* TCP是`面向连接的`、`可靠的`、`基于字节流的`传输层通信协议；
	* 面向连接：TCP通信双方必须是1对1的；
	* 可靠：TCP保证一个报文一定能够到达接收端；
	* 基于字节流：数据经过TCP协议分片并封装成二进制流格式传输；

### TCP连接
> 建立一个TCP连接需要通信双方达成三个共识：
* socket：IP地址+端口号
* 序列号：解决乱序
* 窗口大小：流量控制

> 一个TCP四元组可以唯一确定一个连接：
* 源IP地址
* 目的IP地址
* 源端口号
* 目的端口号

> 理论上监听的端口能够维护的TCP连接数最大为：2^32 * 2^16 = 2^48，但具体的肯定会受到限制，比如：
* 系统最大文件描述符个数的限制；
* 系统内存的限制；

### TCP vs UDP 以及应用场景
> UDP头格式
* 16源端口 + 16目的端口
* 16包长度 + 16校验和
![](UDP报文格式.png)
* 包长度：包含了UDP首部长度（8字节）和数据部分的长度；
* 校验和：防止数据包受损

> TCP与UDP的区别：
* 连接：
	* TCP需要三次握手建立连接，TCP只能一对一；
	* UDP不需要连接，可以一对一、一对多、多对多；
* 可靠性：
	* TCP是可靠交付数据的，保证数据的无差错、无重复、不乱序、不丢失到达；
	* UDP尽最大努力交付数据，不保证可靠交付数据；
* 拥塞控制、流量控制：
	* TCP根据自身以及网络状态对收发数据包做必要控制；
	* UDP...
* 首部开销：
	* TCP至少有20字节的首部开销（可能有可选字段）
	* UDP只有8字节的首部开销
* 传输方式和分片方式不同：
	* TCP基于字节流传输，若一次要传输的数据太大（数据超过MSS），在TCP层就进行分片，组成多个TCP包发送；
	* UDP没有长度限制，直接将要传输的数据作为自己的数据字段发生，在IP层封装后若IP包超过MTU，则会进行分片；

> 应用场景：
* TCP：用于HTTP/HTTPS、FTP等应用程序；
* UDP：用于DNS、视频、音频等通信以及广播通信等；

### TCP和UDP可以使用同一个端口吗
> 可以，TCP协议栈、UDP协议栈在内核中是两个相互独立的模块，各自的端口号也是独立的，操作系统会根据收到的IP包中的`协议号`字段来判断将数据交给TCP模块还是UDP模块。

## TCP三次握手

### 三次握手流程
![](TCP三次握手状态图.png)

* 初始阶段，客户端和服务端都处于`Close`状态；
* 服务端开启监听某个端口后，处于`Listen`状态；
* 客户端初始化一个随机序号，并填入TCP报文的序列号字段，然后将SYN字段设置为1，该报文不包含应用层数据，将这个SYN包发送给服务器，客户端进入`Syn_sent`状态；
* 服务端接受到客户端发送的SYN包，初始化一个随机序号，填入TCP报文的序列号字段，然后将SYN字段设置为1，将收到的SYN包的序列号+1填入TCP报文的确认号字段中，将ACK字段设置为1，表示这是对客户端发送的SYN包的确认，并期待收到序列号为上一个序列号+1的报文，然后将该报文发送给客户端，该报文也不携带应用层数据，服务端进入`Syn_rcvd`状态；
* 客户端收到服务端的SYN+ACK报文后，需要针对服务端的SYN回复一个ACK报文，将报文的确认号设置为收到的报文的序列号+1，将ACK字段设置为1，该报文可以携带应用层数据，将该报文发生给服务端，客户端进入`Established`状态；
* 服务端收到客户端的ACK报文后，也进入`Established`状态；

> 注意：前两次握手是不可以携代数据的，第三次握手可以携带。

### Linux中查看TCP状态指令
> 使用`netstat -napt`查看

```shell
ubuntu@VM-16-12-ubuntu:~$ netstat -napt
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      -
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -
tcp        0      0 10.0.16.12:37594        169.254.0.55:5574       ESTABLISHED -
tcp        0      0 10.0.16.12:22           175.139.236.193:41520   TIME_WAIT   -
tcp        0      0 10.0.16.12:43774        169.254.0.138:8186      ESTABLISHED -
tcp        0      0 10.0.16.12:37602        169.254.0.55:5574       ESTABLISHED -
tcp        0    360 10.0.16.12:22           223.104.246.76:7111     ESTABLISHED -
tcp        0      0 10.0.16.12:34626        169.254.0.4:80          TIME_WAIT   -
tcp        0      0 10.0.16.12:49486        169.254.0.55:8080       TIME_WAIT   -
tcp6       0      0 :::111                  :::*                    LISTEN      -
```

### 为什么不是两次握手、四次握手
> 首先，三次握手是为了确保通信双方能够建立TCP连接；
> TCP连接是用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括socket、序列号、窗口大小称为连接；
> 那么这个问题可以转换为：为什么三次握手才可以初始化socket、序列号、窗口大小并建立TCP连接。

* 三次握手可以阻止重复历史连接的初始化（主要原因）；
* 三次握手可以同步通信双方的初始序列号；
* 三次握手可以避免资源浪费；




## TCP四次挥手


## socket编程


## TCP重传机制

## TCP滑动窗口

## TCP流量控制

## TCP拥塞控制



