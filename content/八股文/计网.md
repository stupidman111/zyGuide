
# TCP/IP网络模型与OSI网络模型
> ...


* TCP/IP分为哪几层？作用分别是？
	* 应用层：负责提供应用服务，如HTTP、FTP、DNS、SMTP等；
	* 传输层：负责端到端的传输，有TCP、UDP；
	* 网络层：负责网络包的封装、分片、路由、转发，有IP、ICMP、ARP；
	* 网络接口层：负载网络包在物理网络中的传输，如网络包的封帧、MAC寻址、差错检测、通过网卡传输网络帧等；
* OSI分为哪几层，作用分别是：
	* 应用层：给应用程序提供统一接口
	* 表示层：编码、解码
	* 会话层：建立、管理、终止实体之间的通话
	* 传输层：端到端的传输
	* 网络层：分片、寻址、路由
	* 数据链路层：封帧、MAC寻址
	* 物理层：物理网络中传输数据帧
* TCP/IP与OSI的对应关系：
	* TCP/IP的应用层--OSI的应用层、表示层、会话层
	* TCP/IP的传输层--OSI的传输层
	* TCP/IP的网络层--OSI的网络层
	* TCP/IP的网络接口层--OSI的数据链路层、物理层

# 键入网址到网页显示流程
> 涉及：HTTP、DNS、OS、TCP、IP、MAC、网卡、交换机、路由器等


* 浏览器解析URL，获取域名、访问路径等信息，生成HTTP请求信息
	* 
* 查DNS获取域名对应的IP地址信息
	* 域名解析流程（比如要获取www.server.com的IP地址）
		* 访问缓存；
		* 访问本地域名服务器；
		* 根据本地域名服务器保存的根域名服务器的地址`.`，访问根域名服务器；
		* 根据根域名服务器返回的顶级域名服务器的地址`.com`，访问顶级域名服务器；
		* 根据顶级域名服务器返回的权威域名服务器的地址`server.com`，访问权威域名服务器；
		* 权威域名服务器返回`server.com`的IP地址给本地域名服务器，本地域名服务器将地址返回给客户端；
* 封装HTTP消息
* 调用Socket库发送HTTP消息
* 封装成TCP
* 封装成IP
* 封装成MAC
* 由网卡驱动程序控制网卡发送二进制数据
* 交换机
* 路由器
* 到达目的服务器进行解封装


# Linux如何收发网络包
> 参考资料：
>  [Linux 网络包发送过程](https://mp.weixin.qq.com/s/wThfD9th9e_-YGHJJ3HXNQ)
>  [Linux 网络数据接收流程（TCP）- NAPI](https://wenfh2020.com/2021/12/29/kernel-tcp-receive/)
>  [Linux网络-数据包接收过程](https://blog.csdn.net/frank_jb/article/details/115841622)


> 从下图中可以看到：
> 	应用程序通过系统调用，来跟Socket层进行数据交互；
> 	Socket层下面就是传输层、网络层、网络接口层；
> 	最下面的一层，是网卡驱动程序和硬件网卡设备；
![](Linux网络协议栈.png)

* Linux接收网络包流程：
* Linux发送网络包流程：

> 在Linux中，全部的数据包都用一个结构体`sk_buff`来描述，对于每一种协议对应的数据包，只需要移动该结构体中`data`的指针即可；这样可以避免大量的数据拷贝的工作；


* 接收网络数据时，涉及几次内存拷贝操作？
* 发送网络数据时，涉及几次内存拷贝操作？


# HTTP

## HTTP基本概念
> HTTP----HyperText Transfer Protocol---`超文本-传输-协议`

### HTTP常见状态码
* `1XX`：表示传输流转状态，是一种中间状态；
* `2XX`：表示传输成功，具体地有：
	* `200 OK`：最常见的成功状态码，表示一切正常；
	* `204 No Content`：响应头没有body数据；
	* `206 Partial Content`：返回的HTTP消息是分块传输的；
* `3XX`：表示重定向，具体地有：
	* `301 Moved Permanently`：永久重定向，一般在响应头中使用Location指明重定向后的URL；
	* `302 Found`：临时重定向，一般在响应头中使用Location指明重定向后的URL；
	* `304 Not Modified`：走缓存；
* `4XX`：客户端报文错误，具体地有：
	* `400 Bad Request`：表示客户端请求报文有错误，服务端无法识别；
	* `403 Forbidden`：表示服务器禁止访问资源，并不是客户端请求出错；
	* `404 Not Fount`：表示客户端访问的资源不存在；
* `5XX`：服务器内部错误，具体地有：
	* `500 Internal Server Error`：服务器内部错误；
	* `501 Not Implemented`：访问的资源还没有实现；
	* `502 Bad Gateway`：代理或网关错误，服务器本身正常；
	* `503 Service Unavailable`：服务器忙；

### HTTP常见字段
> ...

* `Host`：访问的服务器域名；
* `Content-Length`：body部分长度；
* `Connection`：连接模式，长连接还是短连接，长连接为`Keep Alive`（与TCP Keep-Alive不是一个东西）；
* `Content-Type`：body部分的数据格式，如`text/html; Charset=utf-8`表示发生的是网页，编码是UTF-8；
* `Accept`：可以接受的数据格式，如`*/*`表示可接受任何形式的数据；
* `Content-Encoding`：数据的压缩方法，如`gzip`
* `Accept-Encoding`：可以接受的压缩方法，如`gzip, deflate`；


## GET与POST
### GET与POST的区别
> ...

* GET的语义：从服务器获取资源，参数一般在URL中，且是ASCII码形式的，浏览器对URL参数长度做了限制；
* POST的语义：根据请求体中的数据，对服务器进行一定的更改，URL中也可以携带参数，数据长度一般没有限制；
### 安全与幂等
> ...

* 安全：对服务器的操作不会改变服务器上的数据；
* 幂等：对服务器的多次请求，获得的结果是相同的；
* GET是否是安全且幂等的？
	* 从RFC规定上来看，GET是安全且幂等的，只用来从服务器获取资源；
	* 但实际也可以使用GET来修改资源，不过一般不这么做；
	* GET也可以携带body数据；
* POST是否是安全且幂等的？
	* 从RFC规定上来看，POST是非安全且非幂等的，会修改服务器数据；
	* 但实际也可以使用POST来获取资源，不过一般不这么做；
	* POST也可设置URL参数；
> HTTP都是明文传输的，不存在安全一说，但可以通过HTTPS对数据进行加密传输；

## HTTP缓存技术
> 为什么使用缓存技术？
> 	对于某些请求，多次得到的数据都是一样的，那么就可以把这对【请求-响应】的数据缓存在本地，下次就可以直接读取本地数据，从而提高性能。

### 强制缓存
> 强制缓存指的是只要浏览器判断缓存未过期，那么就直接使用缓存里的数据，决定是否使用缓存的主动性在浏览器这边。

可使用以下两个字段来实现：
* `Cache-Control`：一个相对时间，优先级更高
* `Expires`：一个绝对时间

流程：
* 当浏览器第一次访问服务器资源时，服务器返回的响应会在响应头字段中加上`Cache-Control`来设置一个过期时间；
* 下次浏览器对该资源再发起请求时，会先通过请求资源的时间与`Cache-Control`设置的时间进行计算，判断是否过期，没过期就走缓存，过期了就再向服务发起请求；
* 服务器响应会再次更新`Cache-Control`；
### 本地缓存
> 协商缓存指的是某些请求的响应结果状态码是`304-Not Modifed`，表示告知浏览器可以走本地缓存，这种方式是服务器与浏览器协商决定的。

两种实现方式：
* 第一种，可使用以下两个字段来实现：
	* 请求头部中的`If-Modified-Since`：
	* 响应头部中的`Last-Modified`：
* 第二种，


## HTTP特性
> HTTP常见版本：HTTP/1.1、HTTP/2.0、HTTP/3.0

> HTTPS就是在HTTP层与TCP层之间加了一个SSL/TLS安全传输层；
> HTTP/1.1与HTTP/2.0传输协议使用的是TCP协议，而HTTP/3.0使用的是UDP协议；

### HTTP/1.1的优点

* 简单：报文格式为`Header + Body`，头部数据为`Key-Value`格式；
* 灵活、易扩展：
* 应用广泛、跨平台：

### HTTP/1.1的缺点

* 无状态的缺点：
	* 好处：不需要额外记录状态信息；
	* 缺点：对于有关联性的请求会比较麻烦；（如登录->添加购物车->下单->结算->支付，由于无状态，每一次都需要对身份进行验证）
	* 解决：
		* `Cookie-Session技术`：请求达到服务器时，会针对该请求生成一个Session号，并存储部分信息（key-value），保存在服务器的Session中，同时在响应体中Cookie中加上Session号再返回响应给浏览器，浏览器将Cookie中的Session号保存到本地，下次对相同资源发起请求时，携带Session号到Cookie中发生给服务器，服务器通过请求中Cookie中的Session号访问本地Session取出信息进行验证。
		* `Redis技术`：
		* `JWT技术`：
* 明文传输、不安全：
	* 解决方案：引入SSL/TLS层；

### HTTP/1.1的性能

* 长连接：在`Connection-Type`状态中使用`Keep-Alive`字段保持连接；
* 管道网络传输：客户端可以连续发送多次请求，不需要等一个请求发出得到响应后再发送下一个请求，但服务器必须按请求的先后顺序进行处理；这种方式解决了请求的队头阻塞问题，但没有解决服务器响应的队头阻塞问题；且管道传输大部分时间不是默认开启的；
* 队头阻塞：当顺序发生的一个请求因为某种原因被阻塞了迟迟得不到响应，导致后续请求无法发出（这就是未开启管道网络传输的情况）

## HTTP与HTTPS

### HTTP与HTTPS区别
* HTTP使用明文传输，HTTPS使用加密传输
* HTTP建立连接只需要TCP三次握手，HTTPS建立连接需要TCP三次握手、SSL/TSL握手
* HTTP默认使用80端口，HTTPS模式使用443端口
* HTTPS需要向CA-证书权威机构来申请数字证书，来确保服务器身份可信

### HTTPS的特点
* HTTPS采用对称加密与非对称加密混合方式（混合加密）：
	* 对称加密：双方只使用一个密匙，密匙需要保密；
	* 非对称加密：使用两个密匙-公钥、私钥；公钥可以任意分发，而私钥则必须保密；
	* HTTPS通信建立过程中使用非对称加密方式交换`会话密匙`；
	* HTTPS通信过程中使用`会话密匙`以对称加密方式交换加密的明文数据；
	* 非对称加密使用方式：
		* 公钥：公开给所有人，任意分发；
		* 私钥：由服务端管理，不可泄漏；
		* 公钥和私钥可以双向加解密：
			* 公钥加密，私钥解密：目的是保证数据的安全性
			* 私钥加密，公钥解密：目的是保证数据来源的可靠性
* HTTPS使用摘要算法（哈希函数）+数字签名的方式保证数据内容不被篡改：
	* 先用摘要算法计算出内容的哈希值（指纹），哈希值是唯一的，无法通过哈希值推导出内容，然后将内容同哈希值一起发送；
	* 接收方也使用摘要算法对接收到的内容部分计算出一个哈希值，然后与接收到的哈希值进行比较，若相同，这数据内容是安全的，否则则不安全；
	* 这里的数字签名算法使用的就是私钥加密-公钥解密的一种实现方式：
		* 使用私钥（数字签名算法）对摘要算法计算出的内容的哈希值进行加密；
		* 使用公钥（数字签名算法）对所得到的哈希值进行解密；
	* 整体流程为：
		* 服务端对响应的内容使用摘要算法（哈希函数）进行计算得到哈希值；
		* 服务端使用私钥（数字签名算法）对哈希值进行加密；
		* 客户端使用摘要算法（哈希函数）对内容进行计算得到哈希值；
		* 客户端使用公钥（数字签名算法）对哈希值进行解密；
		* 客户端比对解密得到的哈希值与计算的得到的哈希值是否相同；
* HTTPS使用CA（数字证书认证机构）发布数字证书：
	* 服务器公钥需要放在数字证书中，且由数字证书认证机构来颁发；


* 整体流程：
	* 服务器将自己的公钥注册到CA；
	* CA通过自己的私钥，将服务器注册的公钥加密（数字签名）生成数字证书；
	* 客户端需要访问某个服务器时，会找CA要该服务器的数字证书（即公钥）；
	* CA颁发数字证书给客户端；
	* 客户端从浏览器或操作系统中取出CA的公钥（预置的）；
	* 客户端使用CA的公钥对数字证书进行解密（私钥加密，公钥解密，确定数据来源的可靠性）确认数字证书的可靠性，并得到服务器的公钥；
	* 客户端用获取到的公钥对数据进行加密发送给服务器；
	* 服务器通过自己的私钥对数据进行解密（公钥加密，私钥解密，确保数据内容的安全）
	* 需要注意，上面的过程是客户端与服务器建立连接的过程（使用非对称加密），这个交换的内容是`会话密匙`，当建立成功后，双方只需要通过会话密匙对数据进行加解密通信即可；

### HTTPS如何建立连接的？
> 先进行TCP三次握手建立连接，然后进行TLS四次通信实现握手

* TCP三次握手之后，进行TLS四次通信：
* 第一步，客户端发送ClientHello消息，其中包括：
	* 客户端支持的TLS协议版本；
	* 客户端生成的随机数（用于生成会话密匙的条件之一）---ClientRandom；
	* 客户端支持的密码套件列表，如RSA加密算法等；
* 第二步，服务器收到客户端ClientHello请求后，向客户端发送ServerHello响应，其中包括：
	* 确实TLS协议版本，如果浏览器不支持，则关闭加密通信；
	* 服务器生成的随机数（用于生成会话密匙的条件之一）---ServerRandom；
	* 确认密码套件列表，如RSA加密算法；
	* 服务器的数字证书；
* 第三步，客户端收到ServerHello响应后，根据自己本地存储的CA公钥，对数字证书进行解密，验证服务器公钥的真实性，取出服务器公钥，使用该公钥加密报文，发送以下报文给服务器，其中包括：
	* 一个随机数（用于生成会话密匙的条件之一）---pre master key；
	* 加密通信算法改变通知，表示随后的信息采用【会话密匙】进行加密通信；
	* 客户端握手结束通知；表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验；
* 第四步，服务器收到客户端的随机数pre master key，想客户端发送建立连接的最后通信：
	* 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信；
	* 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验；
> 上述三个用于生成会话密匙的条件，此时双方都已经持有，于是双方都可以使用这三个随机数，加上协商过程中商定的加密算法，比如RSA，生成【会话密匙】。

* 后续的通信都是要【会话密匙】进行对称加密通信；

### HTTPS数据如何保证完整性？

### HTTPS一定安全可靠吗？