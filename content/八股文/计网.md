
# TCP/IP网络模型与OSI网络模型
> ...


* TCP/IP分为哪几层？作用分别是？
	* 应用层：负责提供应用服务，如HTTP、FTP、DNS、SMTP等；
	* 传输层：负责端到端的传输，有TCP、UDP；
	* 网络层：负责网络包的封装、分片、路由、转发，有IP、ICMP、ARP；
	* 网络接口层：负载网络包在物理网络中的传输，如网络包的封帧、MAC寻址、差错检测、通过网卡传输网络帧等；
* OSI分为哪几层，作用分别是：
	* 应用层：给应用程序提供统一接口
	* 表示层：编码、解码
	* 会话层：建立、管理、终止实体之间的通话
	* 传输层：端到端的传输
	* 网络层：分片、寻址、路由
	* 数据链路层：封帧、MAC寻址
	* 物理层：物理网络中传输数据帧
* TCP/IP与OSI的对应关系：
	* TCP/IP的应用层--OSI的应用层、表示层、会话层
	* TCP/IP的传输层--OSI的传输层
	* TCP/IP的网络层--OSI的网络层
	* TCP/IP的网络接口层--OSI的数据链路层、物理层

# 键入网址到网页显示流程
> 涉及：HTTP、DNS、OS、TCP、IP、MAC、网卡、交换机、路由器等


* 浏览器解析URL，获取域名、访问路径等信息，生成HTTP请求信息
	* 
* 查DNS获取域名对应的IP地址信息
	* 域名解析流程（比如要获取www.server.com的IP地址）
		* 访问缓存；
		* 访问本地域名服务器；
		* 根据本地域名服务器保存的根域名服务器的地址`.`，访问根域名服务器；
		* 根据根域名服务器返回的顶级域名服务器的地址`.com`，访问顶级域名服务器；
		* 根据顶级域名服务器返回的权威域名服务器的地址`server.com`，访问权威域名服务器；
		* 权威域名服务器返回`server.com`的IP地址给本地域名服务器，本地域名服务器将地址返回给客户端；
* 封装HTTP消息
* 调用Socket库发送HTTP消息
* 封装成TCP
* 封装成IP
* 封装成MAC
* 由网卡驱动程序控制网卡发送二进制数据
* 交换机
* 路由器
* 到达目的服务器进行解封装


# Linux如何收发网络包
> 参考资料：
>  [Linux 网络包发送过程](https://mp.weixin.qq.com/s/wThfD9th9e_-YGHJJ3HXNQ)
>  [Linux 网络数据接收流程（TCP）- NAPI](https://wenfh2020.com/2021/12/29/kernel-tcp-receive/)
>  [Linux网络-数据包接收过程](https://blog.csdn.net/frank_jb/article/details/115841622)


> 从下图中可以看到：
> 	应用程序通过系统调用，来跟Socket层进行数据交互；
> 	Socket层下面就是传输层、网络层、网络接口层；
> 	最下面的一层，是网卡驱动程序和硬件网卡设备；
![](Linux网络协议栈.png)

* Linux接收网络包流程：
* Linux发送网络包流程：

> 在Linux中，全部的数据包都用一个结构体`sk_buff`来描述，对于每一种协议对应的数据包，只需要移动该结构体中`data`的指针即可；这样可以避免大量的数据拷贝的工作；


* 接收网络数据时，涉及几次内存拷贝操作？
* 发送网络数据时，涉及几次内存拷贝操作？


# HTTP

## HTTP基本概念
> HTTP----HyperText Transfer Protocol---`超文本-传输-协议`

### HTTP常见状态码
* `1XX`：表示传输流转状态，是一种中间状态；
* `2XX`：表示传输成功，具体地有：
	* `200 OK`：最常见的成功状态码，表示一切正常；
	* `204 No Content`：响应头没有body数据；
	* `206 Partial Content`：返回的HTTP消息是分块传输的；
* `3XX`：表示重定向，具体地有：
	* `301 Moved Permanently`：永久重定向，一般在响应头中使用Location指明重定向后的URL；
	* `302 Found`：临时重定向，一般在响应头中使用Location指明重定向后的URL；
	* `304 Not Modified`：走缓存；
* `4XX`：客户端报文错误，具体地有：
	* `400 Bad Request`：表示客户端请求报文有错误，服务端无法识别；
	* `403 Forbidden`：表示服务器禁止访问资源，并不是客户端请求出错；
	* `404 Not Fount`：表示客户端访问的资源不存在；
* `5XX`：服务器内部错误，具体地有：
	* `500 Internal Server Error`：服务器内部错误；
	* `501 Not Implemented`：访问的资源还没有实现；
	* `502 Bad Gateway`：代理或网关错误，服务器本身正常；
	* `503 Service Unavailable`：服务器忙；

### HTTP常见字段
> ...

* `Host`：访问的服务器域名；
* `Content-Length`：body部分长度；
* `Connection`：连接模式，长连接还是短连接，长连接为`Keep Alive`（与TCP Keep-Alive不是一个东西）；
* `Content-Type`：body部分的数据格式，如`text/html; Charset=utf-8`表示发生的是网页，编码是UTF-8；
* `Accept`：可以接受的数据格式，如`*/*`表示可接受任何形式的数据；
* `Content-Encoding`：数据的压缩方法，如`gzip`
* `Accept-Encoding`：可以接受的压缩方法，如`gzip, deflate`；


## GET与POST
### GET与POST的区别
> ...

* GET的语义：从服务器获取资源，参数一般在URL中，且是ASCII码形式的，浏览器对URL参数长度做了限制；
* POST的语义：根据请求体中的数据，对服务器进行一定的更改，URL中也可以携带参数，数据长度一般没有限制；
### 安全与幂等
> ...

* 安全：对服务器的操作不会改变服务器上的数据；
* 幂等：对服务器的多次请求，获得的结果是相同的；
* GET是否是安全且幂等的？
	* 从RFC规定上来看，GET是安全且幂等的，只用来从服务器获取资源；
	* 但实际也可以使用GET来修改资源，不过一般不这么做；
	* GET也可以携带body数据；
* POST是否是安全且幂等的？
	* 从RFC规定上来看，POST是非安全且非幂等的，会修改服务器数据；
	* 但实际也可以使用POST来获取资源，不过一般不这么做；
	* POST也可设置URL参数；
> HTTP都是明文传输的，不存在安全一说，但可以通过HTTPS对数据进行加密传输；

## HTTP缓存技术
> 为什么使用缓存技术？
> 	对于某些请求，多次得到的数据都是一样的，那么就可以把这对【请求-响应】的数据缓存在本地，下次就可以直接读取本地数据，从而提高性能。

### 强制缓存
> 强制缓存指的是只要浏览器判断缓存未过期，那么就直接使用缓存里的数据，决定是否使用缓存的主动性在浏览器这边。

可使用以下两个字段来实现：
* `Cache-Control`：一个相对时间，优先级更高
* `Expires`：一个绝对时间

流程：
* 当浏览器第一次访问服务器资源时，服务器返回的响应会在响应头字段中加上`Cache-Control`来设置一个过期时间；
* 下次浏览器对该资源再发起请求时，会先通过请求资源的时间与`Cache-Control`设置的时间进行计算，判断是否过期，没过期就走缓存，过期了就再向服务发起请求；
* 服务器响应会再次更新`Cache-Control`；
### 本地缓存
> 协商缓存指的是某些请求的响应结果状态码是`304-Not Modifed`，表示告知浏览器可以走本地缓存，这种方式是服务器与浏览器协商决定的。

两种实现方式：
* 第一种，可使用以下两个字段来实现：
	* 请求头部中的`If-Modified-Since`：
	* 响应头部中的`Last-Modified`：
* 第二种，


## HTTP特性
> HTTP常见版本：HTTP/1.1、HTTP/2.0、HTTP/3.0

> HTTPS就是在HTTP层与TCP层之间加了一个SSL/TLS安全传输层；
> HTTP/1.1与HTTP/2.0传输协议使用的是TCP协议，而HTTP/3.0使用的是UDP协议；

### HTTP/1.1的优点

* 简单：报文格式为`Header + Body`，头部数据为`Key-Value`格式；
* 灵活、易扩展：
* 应用广泛、跨平台：

### HTTP/1.1的缺点

* 无状态的缺点：
	* 好处：不需要额外记录状态信息；
	* 缺点：对于有关联性的请求会比较麻烦；（如登录->添加购物车->下单->结算->支付，由于无状态，每一次都需要对身份进行验证）
	* 解决：
		* `Cookie-Session技术`：请求达到服务器时，会针对该请求生成一个Session号，并存储部分信息（key-value），保存在服务器的Session中，同时在响应体中Cookie中加上Session号再返回响应给浏览器，浏览器将Cookie中的Session号保存到本地，下次对相同资源发起请求时，携带Session号到Cookie中发生给服务器，服务器通过请求中Cookie中的Session号访问本地Session取出信息进行验证。
		* `Redis技术`：
		* `JWT技术`：
* 明文传输、不安全：
	* 解决方案：引入SSL/TLS层；

### HTTP/1.1的性能

* 长连接：在`Connection-Type`状态中使用`Keep-Alive`字段保持连接；
* 管道网络传输：客户端可以连续发送多次请求，不需要等一个请求发出得到响应后再发送下一个请求，但服务器必须按请求的先后顺序进行处理；这种方式解决了请求的队头阻塞问题，但没有解决服务器响应的队头阻塞问题；且管道传输大部分时间不是默认开启的；
* 队头阻塞：当顺序发生的一个请求因为某种原因被阻塞了迟迟得不到响应，导致后续请求无法发出（这就是未开启管道网络传输的情况）

## HTTP与HTTPS

### HTTP与HTTPS区别


### HTTPS解决了HTTP的哪些问题

### HTTPS如何建立连接的？如何交互的？

### HTTPS数据如何保证完整性？

### HTTPS一定安全可靠吗？