
# TCP/IP网络模型与OSI网络模型
> ...


* TCP/IP分为哪几层？作用分别是？
	* 应用层：负责提供应用服务，如HTTP、FTP、DNS、SMTP等；
	* 传输层：负责端到端的传输，有TCP、UDP；
	* 网络层：负责网络包的封装、分片、路由、转发，有IP、ICMP、ARP；
	* 网络接口层：负载网络包在物理网络中的传输，如网络包的封帧、MAC寻址、差错检测、通过网卡传输网络帧等；
* OSI分为哪几层，作用分别是：
	* 应用层：给应用程序提供统一接口
	* 表示层：编码、解码
	* 会话层：建立、管理、终止实体之间的通话
	* 传输层：端到端的传输
	* 网络层：分片、寻址、路由
	* 数据链路层：封帧、MAC寻址
	* 物理层：物理网络中传输数据帧
* TCP/IP与OSI的对应关系：
	* TCP/IP的应用层--OSI的应用层、表示层、会话层
	* TCP/IP的传输层--OSI的传输层
	* TCP/IP的网络层--OSI的网络层
	* TCP/IP的网络接口层--OSI的数据链路层、物理层

# 键入网址到网页显示流程
> 涉及：HTTP、DNS、OS、TCP、IP、MAC、网卡、交换机、路由器等


* 浏览器解析URL，获取域名、访问路径等信息，生成HTTP请求信息
	* 
* 查DNS获取域名对应的IP地址信息
	* 域名解析流程（比如要获取www.server.com的IP地址）
		* 访问缓存；
		* 访问本地域名服务器；
		* 根据本地域名服务器保存的根域名服务器的地址`.`，访问根域名服务器；
		* 根据根域名服务器返回的顶级域名服务器的地址`.com`，访问顶级域名服务器；
		* 根据顶级域名服务器返回的权威域名服务器的地址`server.com`，访问权威域名服务器；
		* 权威域名服务器返回`server.com`的IP地址给本地域名服务器，本地域名服务器将地址返回给客户端；
* 封装HTTP消息
* 调用Socket库发送HTTP消息
* 封装成TCP
* 封装成IP
* 封装成MAC
* 由网卡驱动程序控制网卡发送二进制数据
* 交换机
* 路由器
* 到达目的服务器进行解封装


# Linux如何收发网络包
> 参考资料：
>  [Linux 网络包发送过程](https://mp.weixin.qq.com/s/wThfD9th9e_-YGHJJ3HXNQ)
>  [Linux 网络数据接收流程（TCP）- NAPI](https://wenfh2020.com/2021/12/29/kernel-tcp-receive/)
>  [Linux网络-数据包接收过程](https://blog.csdn.net/frank_jb/article/details/115841622)


> 从下图中可以看到：
> 	应用程序通过系统调用，来跟Socket层进行数据交互；
> 	Socket层下面就是传输层、网络层、网络接口层；
> 	最下面的一层，是网卡驱动程序和硬件网卡设备；
![](Linux网络协议栈.png)

* Linux接收网络包流程：
* Linux发送网络包流程：

> 在Linux中，全部的数据包都用一个结构体`sk_buff`来描述，对于每一种协议对应的数据包，只需要移动该结构体中`data`的指针即可；这样可以避免大量的数据拷贝的工作；


* 接收网络数据时，涉及几次内存拷贝操作？
* 发送网络数据时，涉及几次内存拷贝操作？


# HTTP

## HTTP基本概念
> HTTP----HyperText Transfer Protocol---`超文本-传输-协议`

### HTTP常见状态码
* `1XX`：表示传输流转状态，是一种中间状态；
* `2XX`：表示传输成功，具体地有：
	* `200 OK`：最常见的成功状态码，表示一切正常；
	* `204 No Content`：响应头没有body数据；
	* `206 Partial Content`：返回的HTTP消息是分块传输的；
* `3XX`：表示重定向，具体地有：
	* `301 Moved Permanently`：永久重定向，一般在响应头中使用Location指明重定向后的URL；
	* `302 Found`：临时重定向，一般在响应头中使用Location指明重定向后的URL；
	* `304 Not Modified`：走缓存；
* `4XX`：客户端报文错误，具体地有：
	* `400 Bad Request`：表示客户端请求报文有错误，服务端无法识别；
	* `403 Forbidden`：表示服务器禁止访问资源，并不是客户端请求出错；
	* `404 Not Fount`：表示客户端访问的资源不存在；
* `5XX`：服务器内部错误，具体地有：
	* `500 Internal Server Error`：服务器内部错误；
	* `501 Not Implemented`：访问的资源还没有实现；
	* `502 Bad Gateway`：代理或网关错误，服务器本身正常；
	* `503 Service Unavailable`：服务器忙；

### HTTP常见字段
> ...

* `Host`：访问的服务器域名；
* `Content-Length`：body部分长度；
* `Connection`：连接模式，长连接还是短连接，长连接为`Keep Alive`（与TCP Keep-Alive不是一个东西）；
* `Content-Type`：body部分的数据格式，如`text/html; Charset=utf-8`表示发生的是网页，编码是UTF-8；
* `Accept`：可以接受的数据格式，如`*/*`表示可接受任何形式的数据；
* `Content-Encoding`：数据的压缩方法，如`gzip`
* `Accept-Encoding`：可以接受的压缩方法，如`gzip, deflate`；


## GET与POST
### GET与POST的区别
> ...

* GET的语义：从服务器获取资源，参数一般在URL中，且是ASCII码形式的，浏览器对URL参数长度做了限制；
* POST的语义：根据请求体中的数据，对服务器进行一定的更改，URL中也可以携带参数，数据长度一般没有限制；
### 安全与幂等
> ...

* 安全：对服务器的操作不会改变服务器上的数据；
* 幂等：对服务器的多次请求，获得的结果是相同的；
* GET是否是安全且幂等的？
	* 从RFC规定上来看，GET是安全且幂等的，只用来从服务器获取资源；
	* 但实际也可以使用GET来修改资源，不过一般不这么做；
	* GET也可以携带body数据；
* POST是否是安全且幂等的？
	* 从RFC规定上来看，POST是非安全且非幂等的，会修改服务器数据；
	* 但实际也可以使用POST来获取资源，不过一般不这么做；
	* POST也可设置URL参数；
> HTTP都是明文传输的，不存在安全一说，但可以通过HTTPS对数据进行加密传输；

## HTTP缓存技术
> 为什么使用缓存技术？
> 

### 强制缓存

### 本地缓存


