
# CPU缓存一致性

## 内存与Cache一致性
> 对于写操作，要保证内存与Cache的一致性，有`写直达`和`写回`两种。

* 写直达：将数据同时写入Cache和内存中；
	* 如果数据已经在Cache中，那么将数据先写入Cache，在写入内存；
	* 如果数据不在Cache中，那么将数据直接写入内存；
	* 每次都需要写内存，开销大；
* 写回：发送写操作时只将数据写入到Cache块中，并标记该Cache块的数据为脏数据，当Cache块要被替换时，才根据其脏位来判断是否要将该Cache块的数据写回内存；
	* 发生写操作时，定位到的Cache块是【对应内存地址的数据】，那么将数据直接写入Cache，并设置其脏位，标记为脏数据；
	* 发送写操作时，定位到的Cache块不是【对应内存地址的数据】，那么检查该Cache块的数据是否为脏的：
		* 若为脏的，则将其写回内存，将要修改的内存地址的数据读入该Cache块，修改它，并设置其脏位，标记为脏数据；
		* 若不是脏的，直接将要修改的内存地址的数据读入Cache，修改它，并标记为脏；

## 缓存一致性问题
> 多核CPU的每个核心都有自己独立的`L1/L2 Cache`，所以会存在缓存一致性的问题。

* 同步不同核心中的缓存数据的两个原则：
	* 写传播：某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache；
	* 事务的串行化：某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的；
* 写传播的实现---`总线嗅探`：
	* 保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道（其他CPU核心需要监听总线上的广播事件）
* 事务串行化的实现---`MESI`协议：
	* `Modified`--已修改：该Cache块为脏数据；
	* `Exclusive`--独占：数据只存在于一个核心中；
	* `Shared`--共享：数据存在于多个核心中；
	* `Invalidated`--已失效：该Cache块中数据已经失效；






# 进程与线程管理

## 死锁

* 死锁的四个必要条件：
	* 互斥条件：资源只能被一个线程占用
	* 请求并保持条件：
	* 不剥夺条件：
	* 循环等待条件：
* 预防死锁：至少破坏死锁发生的一个条件。
	* 互斥条件：一般不可行，加锁就是为了互斥；
	* 请求并保持：线程在开始执行前一次性申请完全部所需资源，这种情况下会造成资源的严重浪费，因为线程声明周期可能很长，但对某个资源可能一直占有，而不使用，也不释放；
	* 不剥夺：占用资源的线程若申请不到别的资源可以主动释放已有资源。
	* 循环等待：按照某一顺序申请资源，释放资源则反序释放。
* 避免死锁：银行家算法
	* 借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。
		**安全状态** 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>` 序列为安全序列。
* 排查：
	* 使用top命令，按H进入查看。
	* jps查看Java进程，jstack跟踪堆栈信息。

