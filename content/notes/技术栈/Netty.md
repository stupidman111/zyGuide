# 基本的 I/O 模型
基本的 I/O 模型有五种 ：

* 阻塞 I/O：应用程序在执行 I/O 操作时会被阻塞，直到操作完成。例如，在读取数据时，程序会等待数据被完全读取到缓冲区后才继续执行。
	- **优点**：简单直观，易于实现和理解。
	- **缺点**：效率低，因为程序在等待 I/O 操作完成期间不能做其他事情。

* 非阻塞 I/O：**非阻塞 I/O** 允许应用程序在等待 I/O 操作完成时继续执行其他任务。通过将 I/O 操作设置为非阻塞模式，应用程序可以立即返回而不会被阻塞，如果数据还未准备好，会返回一个错误而不是等待。
	- **优点**：提高了程序的响应速度，因为它不需要等待 I/O 操作完成。
	- **缺点**：需要反复检查 I/O 操作是否完成（通常通过轮询），可能会导致高 CPU 占用。

* 多路 I/O 复用：是指使用一个单独的线程来监视多个 I/O 描述符，通过系统调用（如 `select`、`poll`、`epoll` 等）来等待其中一个或多个描述符变为可用。一旦有描述符变为可用，程序可以处理相应的 I/O 操作。
	- **优点**：能够有效管理大量 I/O 描述符，适用于处理大量并发连接的情况，如服务器应用。
	- **缺点**：实现较为复杂，`select` 和 `poll` 在处理大量描述符时效率较低。

* 信号驱动 I/O：**信号驱动 I/O** 是通过操作系统发送信号通知应用程序某个 I/O 描述符变为可用。当 I/O 操作可以进行时，操作系统会发送一个信号（例如 `SIGIO`），应用程序可以在信号处理程序中处理 I/O 操作。
	- **优点**：应用程序不需要一直检查 I/O 描述符，可以更高效地利用 CPU。
	- **缺点**：信号处理复杂，编写和调试信号驱动程序较为困难，信号的处理也是异步的，需要特别注意线程安全。

* 异步 I/O：它允许应用程序在发起 I/O 操作后立即返回并继续执行其他任务，而不必等待 I/O 操作完成。异步 I/O 的核心思想是将 I/O 操作的完成与应用程序的执行解耦，使得应用程序可以在 I/O 操作进行的同时继续处理其他逻辑。
	* 工作原理：
		- **发起 I/O 请求**：应用程序发起一个异步 I/O 请求，并将相关的 I/O 操作信息（如文件描述符、缓冲区地址等）传递给操作系统。
		- **立即返回**：操作系统接受请求并立即返回，应用程序可以继续执行其他任务。
		- **I/O 操作进行中**：操作系统在后台完成实际的 I/O 操作，不阻塞应用程序的执行。
		- **通知完成**：一旦 I/O 操作完成，操作系统会通过某种机制（如回调函数、事件、信号等）通知应用程序，应用程序可以随后处理完成的 I/O 操作。
	- 优点：
	- 缺点：
> 其中，阻塞 I/O、非阻塞 I/O、多路 I/O 复用、信号驱动 I/O 都属于`同步 I/O`。

> 阻塞与非阻塞的区别：
> 
> 阻塞是指执行 I/O 操作时，需要等待数据到达缓冲区，然后才进行读写；
> 
> 非阻塞是指执行 I/O 操作时，数据到达缓冲区是由 OS 做的，如果没有数据就立即返回，过一段时间（轮询）再来检查数据是否准备好，准备好了才开始读写；
> 

> 同步与异步的区别：
> 
> 是否需要进程自己再调用 I/O 读写函数，同步 I/O 需要，异步 I/O 不需要。（异步 I/O 肯定是非阻塞的）



# BIO / NIO / AIO
* BIO-Blocking I/O：同步阻塞 I/O 模式
* NIO-Non-Blocking I/O：同步非阻塞 I/O 模式
* AIO-Asyn I/O：异步 I/O




# Netty
> [Netty](http://netty.io/) 是一个提供 asynchronous event-driven （异步事件驱动）的网络应用框架，是一个用以快速开发高性能、可扩展协议的服务器和客户端。
> 
> 换句话说，Netty 是一个 NIO 客户端服务器框架，使用它可以快速简单地开发网络应用程序，比如服务器和客户端的协议。Netty 大大简化了网络程序的开发过程比如 TCP 和 UDP 的 socket 服务的开发。