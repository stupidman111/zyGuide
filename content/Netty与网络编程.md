# I/O
## I/O的步骤
 > 一般I/O分为两步：
* 等待：等待缓冲区里数据的准备，接受到的数据会先存在内核缓冲区中（page cache）
* 数据搬移：数据从内核缓冲区搬移到用户空间中

## 五种I/O模型
* 阻塞I/O模型：调用`xxx`系统调用后，会有两个等待（这两个等待都会使线程阻塞挂起）
	* 第一个阻塞等待：等待缓冲区里数据准备好，接受到的数据会先存在内核缓冲区中；
	* 第二个阻塞等待：等待内核缓冲区里的数据拷贝到用户空间；
* 非阻塞I/O模型：调用`xxx`系统调用后，会先检查内核数据是否准备好，如果没准备后会立即返回，用户需要 不断调用 或者 间隔一段时间调用（期间可以做一会别的事情） 该系统调用去检查内核数据是否准备好；一旦某一次检查到内核数据准备好了，就会阻塞等待内核缓冲区里的数据拷贝到用户空间；
	* 多个轮询访问：多次调用`xxx`系统调用查看内核数据是否准备好；
	* 一个阻塞等待：一旦内核数据准备好，就立马阻塞等待数据从内核缓冲区拷贝到用户空间；
* 多路复用I/O模型：select / poll / epoll 都属于多路复用I/O模型，
	* select：将需要监听的socket存放到select的文件描述符集合当中，该文件描述符集合是位图形式的，大小为1024，意味着我们使用select最多可以监听1024个socket。当我们调用select的时候，会将文件描述符集合`拷贝`到内核空间，让内核来检查是否有事件发生，检查就是`遍历`文件描述符集合，当检查到有事件发生时，将对应的文件描述符标记为可读/可写。当一次遍历完，再把整个文件描述符集合`拷贝`到用户空间，用户还需要`遍历`找到可读/可写的socket。
		* 两次拷贝：
			* 第一次：将文件描述符集合拷贝到内核空间，交给内核监听事件；
			* 第二次：将文件描述符集合拷贝到用户空间，交给用户处理事件；
		* 两次遍历：
			* 第一次：内核会以遍历文件描述符集合的方式，检查是否有事件发生；
			* 第二次：用户需要遍历文件描述符集合找到内核标记了发生事件的socket；
	* poll：不再使用位图作为文件描述符集合，使用链表组织的动态数组来维护，但同样还是需要扫描，
	* epoll：使用`epoll_create`创建epoll对象，调用`epoll_ctl`将需要监听的socket交给epoll来监听，最后调用`epoll_wait`等待数据。epoll在内核中维护红黑树来保存交给epoll监听的socket，并维护一个链表来记录就绪事件，所有事件发生了的socket都会加入到该链表当中，当用户调用epool_wait时，内核中的就绪事件socket链表会拷贝到用户空间，不再需要扫描的方式来确定那个文件描述符发生了事件。
	* 多路复用I/O模型在一次系统调用select/poll/epoll后，仍然需要阻塞，但能够监听到多个socket的数据是否准备好，从每个socket中读取数据时，还是会阻塞一次；
		* 第一个阻塞等待：调用select/poll/epoll同时检查多个socket的内核数据是否准备好；
		* 接着n个阻塞等待：对select/poll/epoll返回的n个准备好数据的socket，每一个都需要调用系统调用将他们从内核缓冲区读取到用户空间中。
* 信号驱动I/O模型：线程先向内核注册一个信号处理函数，然后用户线程返回不阻塞，当内核数据准备好时向线程发送一个信号，线程在对应的信号处理函数中调用I/O（阻塞）读取数据，即将数据从内核拷贝到用户空间
	* 一个阻塞等待：线程接受到信号后执行信号处理函数调用I/O阻塞读取数据。
* 异步I/O模型：线程调用`xxx`系统调用后立即返回，内核将`准备内核数据`、`内核数据拷贝到用户空间`这两个操作都完成后再发送信号给线程，线程执行自定义的信号处理函数。

## 易混淆概念
* 同步与异步：主要看请求发起方对于消息结果的获取是主动发起的（同步），还是被动通知的（异步）；
* 同步阻塞：请求方主动发起后，需要一直阻塞等待（等待内核数据准备，等待数据从内核拷贝到用户空间）
* 同步非阻塞：请求方主动发起后立即返回，间隔时间（期间可以做其他事情）来询问内核数据是否准备好，当某次询问发现数据准备好后，再阻塞等待数据从内核拷贝到缓冲区。
* 异步阻塞：请求⽅发起请求，⼀直阻塞等待应答结果
* 异步非阻塞：请求方发起后，立即返回，直到内核数据准备后、数据从内核拷贝到用户空间后才接到通知直接处理数据。

## select / poll / epoll

## epoll的事件触发模式：边缘触发、水平触发
* 边缘触发：当被监控的socket上有可读事件发生时，服务器端只会从epoll_wait中苏醒一次，即使进程没有调用read从内核读取数据，也依然只会苏醒一次，因此需要保证一次性将内核缓冲区中的数据读完。 
* 水平触发：当被监控的socket上有可读事件发生时，服务器端不断地从epoll_wait中苏醒。即只要监听的socket有可读事件发生就会苏醒，只要数据未被读取的socket再次被epoll_wait，就会立即苏醒，

## 高性能网络模式---Reactor
> 应用：Redis、Nginx、Netty

* I/O多路复用select、poll、epoll的使用方式是面向过程的方式；
* 而Reactor是基于select、poll、epoll封装出的面向对象方式的网络模式；

> Reactor模式主要由 Reactor 和 处理资源池（线程池） 这两个核心部分组成
* Reactor负责监听、分发事件，事件类型包含连接事件、读写事件；
* 处理资源池负责处理事件，如：read->业务逻辑->send；

> Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：
- Reactor 的数量可以只有一个，也可以有多个；
- 处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程；
> 排列组合这两个因素：
* 一个Reactor，一个进程 / 线程；
* 一个Reactor，多个进程 / 线程；
* 多个Reactor，一个进程 / 线程；---这种方式没必要
* 多个Reactor，多个进程 / 线程；

### 一个Reactor，一个进程 / 线程
> Redis使用的就是`单Reactor单进程`。


### 一个Reactor，多个进程 / 线程


### 多个Reactor，多个进程 / 线程



## 零拷贝


# NIO
