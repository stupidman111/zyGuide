# SQL
* `CHAR_LENGTH`：求字符长度；
* `LENGTH`：求字节长度；


# 事务

# 锁
* 全局锁
* 表级锁
* 行级锁
## 全局锁
```mysql
flush tables with read lock;

unlock tables;
```
> 开启全局锁后，整个数据库都只能进行读操作，其他操作都会阻塞。
> 全局锁主要用于全局逻辑备份


## 表级锁
* 表锁
* 元数据锁（MDL）
* 意向锁
* AUTO-INC锁
### 表锁
```mysql
lock tables table_name read;//表级别共享锁-读锁

lock tables table_name write;//表级别独占锁-写锁

unlock tables;
```
> 满足 读读不互斥、读写互斥、写写互斥。
### 元数据锁（MDL）
> 不需要手动开启，对数据库表操作时，会自动加MDL。
* 对一张表进行CRUD操作，加的是MDL读锁；
* 对一张表结构进行变更的时候，加的是MDL写锁；

> 事务执行期间，MDL一直持有。
> 申请 MDL 锁的操作会形成一个队列，队列中**写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

### 意向锁
> 意向锁的目的是为了快速判断表里是否有记录被加锁。
- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；

> 也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。
> 而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。

* select可以通过添加关键字对记录加共享锁或独占锁。
```mysql
# 先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;

# 先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```

### AUTO-INC锁
> 表里的主键通常都会设置成自增的，这是通过对主键字段声明 `AUTO_INCREMENT` 属性实现的。
> 之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 **AUTO-INC 锁**实现的。


## 行级锁

* Record Lock
* Gap Lock
* Next-Key Lock
* 插入意向锁
### Record Lock
> 记录锁，有S锁和X锁之分。

* S锁与S锁兼容；
* S锁与X锁互斥，X锁与X锁互斥；
### Gap Lock
> 间隙锁，只存在与可重复读隔离级别，目的是为了解决可重复读隔离级别下的幻读问题。

* 比如表中有一个范围id为（3, 5) 的间隙锁，那么就不能插入id为4的这条数据。
> 间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**。
### Next-Key Lock
> 临键锁，Record Lock 和 Gap Lock的组合。

* 比如表中有一个范围id为 (3, 5]的 next-key lock，那么就不能插入id为4的这条记录，也不能修改id为5的这条记录。
> **next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。
### 插入意向锁
> 插入意向锁名字虽然有意向锁，但是它并**不是意向锁，它是一种特殊的间隙锁，属于行级别锁**。

* 如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

### MySQL死锁的发生情况


### 避免MySQL死锁
死锁的四个必要条件：
* 互斥条件
* 请求并保持条件
* 不剥夺条件
* 循环等待条件

在数据库层面，有两种策略通过「打破循环等待条件」来接触死锁状态：
* **设置事务等待锁的超时时间**：超过时间则事务回滚；
* **开启主动死锁检测**：主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。

# MySQL日志
> undo log、 redo log、 binlog

## undo log
> 保障事务的原子性（回滚）
> 实现MVCC

* 回滚：
	* 通过记录的`trx_id`知道该记录是被哪个事务所修改的；
	* 通过记录的`roll_pointer`指针可以将同一条记录的多个`undo log`串联成一个链表，称为`版本链`。
* ReadView + undolog 实现MVCC并发版本控制
	* 事务执行快照读时会根据版本链读取自己可见的数据。
	* 实现可重复读隔离机制。

* 刷盘：
	* undo log和数据页的刷盘策略一样，都需要redo log来保证持久化。
	* buffer pool中也有对应的 undo 页，对undo页的修改也会记录到redo log中，redo log根据对应的刷盘策略来刷盘。

## redo log
> 保证事务四大特性中的`持久性`。
> 宕机重启后，MySQL根据redo log中的内容将数据恢复到最新状态。
> InnoDB层。

记录更新时，想更新Buffer Pool中的数据页，并标记为脏，然后将修改以`redo log`的形式记录；后续由后台线程将缓存在Buffer Pool的脏页刷新到磁盘。
* `WAL`技术：MySQL的写操作并不是立即写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。
* `redo log`是物理日志，记录个某个数据页走了什么修改：
	* 对xxx表空间的YYY数据页ZZZ偏移量的地方做了AAA更新。
* redo log刷盘策略：
	* redo log有自己的缓存--`redo log buffer`
	* 刷盘实际：
		*  MySQL 正常关闭时；
		* 当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；
		* InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。
		* 每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制）
			* 为0：不主动触发刷盘；
			* 为1：每次提交事务都将redo log buffer中的redo log刷盘，会调用`async`函数进行强制刷盘；
			* 为2：每次事务提交都写入到`redo log`，但只是执行`write`写入到`page cache`中，后台线程每隔1s调用一次`async`进行强制刷盘；
## binlog
> binlog用于备份恢复、主从复制。
> MySQL 在完成一条更新操作后，`Server` 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。
> binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。

* MySQL主从复制：
	* 写入Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。
	* 同步Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。
	* 回放Binlog：回放 binlog，并更新存储引擎中的数据。
* Binlog刷盘：
	* 事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。

## buffer pool
> InnoDB存储引擎的缓存池，应用于缓存数据页。并不是Server层的查询缓存（查询缓存的是以sql为key，查询结果为value的键值对）。
> 以16KB的页为单位进行缓存。
> 
* 缓存池会缓存：`数据页`、`索引页`、插入缓存页、`undo页`、自适应哈希索引、锁信息。
* undo页：开启事务后，更新记录前首先要记录对应的`undo log`，如果是更新操作，还需要把被更新的列的旧值记下来生成一条`undo log`写入到undo页当中。

## 两阶段提交
> 目的：避免出现两份日志之间的逻辑不一致的问题。
> 两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。

两阶段提交把单个事务的提交拆分成了2个阶段（针对redo log）：
* 准备阶段：提交事务前写入redo log（prepare阶段）
* 提交阶段：提交事务时写入binlog并设置redo log为commit阶段；



## 问题总结
### undo log 与 redo log 的区别
* redo log记录了此次事务`完成后`的数据状态，记录的是更新之后的值；
	* 事务提交之后发生了崩溃，重启后会通过redo log恢复事务，保证之前提交的数据不会丢失，因为提交了并不代表写入磁盘了。
* undo log记录了此次事务`开始前`的数据状态，记录的是更新之前的值；
	* 事务提交之前发生了崩溃，重启后会通过undo log回滚事务；
### redo log要写入磁盘，数据也要写入磁盘，为什么要多此一举
* 因为数据的修改是先在Buffer Pool中对应的数据页上做的修改，修改后标记为脏页，Buffer Pool中的页写入到磁盘需要一定的时间，且是随机写，比较慢；
* redo log是追加写，磁盘操作是顺序写，速度快，且redo log记录的东西页是关键部分。
### redo log 和 binlog的区别

