

# 事务

# 锁
* 全局锁
* 表级锁
* 行级锁
## 全局锁
```mysql
flush tables with read lock;

unlock tables;
```
> 开启全局锁后，整个数据库都只能进行读操作，其他操作都会阻塞。
> 全局锁主要用于全局逻辑备份


## 表级锁
* 表锁
* 元数据锁（MDL）
* 意向锁
* AUTO-INC锁
### 表锁
```mysql
lock tables table_name read;//表级别共享锁-读锁

lock tables table_name write;//表级别独占锁-写锁

unlock tables;
```
> 满足 读读不互斥、读写互斥、写写互斥。
### 元数据锁（MDL）
> 不需要手动开启，对数据库表操作时，会自动加MDL。
* 对一张表进行CRUD操作，加的是MDL读锁；
* 对一张表结构进行变更的时候，加的是MDL写锁；

> 事务执行期间，MDL一直持有。
> 申请 MDL 锁的操作会形成一个队列，队列中**写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

### 意向锁
> 意向锁的目的是为了快速判断表里是否有记录被加锁。
- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；

> 也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。
> 而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。

* select可以通过添加关键字对记录加共享锁或独占锁。
```mysql
# 先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;

# 先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```

### AUTO-INC锁
> 表里的主键通常都会设置成自增的，这是通过对主键字段声明 `AUTO_INCREMENT` 属性实现的。
> 之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 **AUTO-INC 锁**实现的。


## 行级锁

* Record Lock
* Gap Lock
* Next-Key Lock
* 插入意向锁
### Record Lock
> 记录锁，有S锁和X锁之分。

* S锁与S锁兼容；
* S锁与X锁互斥，X锁与X锁互斥；
### Gap Lock
> 间隙锁，只存在与可重复读隔离级别，目的是为了解决可重复读隔离级别下的幻读问题。

* 比如表中有一个范围id为（3, 5) 的间隙锁，那么就不能插入id为4的这条数据。
> 间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**。
### Next-Key Lock
> 临键锁，Record Lock 和 Gap Lock的组合。

* 比如表中有一个范围id为 (3, 5]的 next-key lock，那么就不能插入id为4的这条记录，也不能修改id为5的这条记录。
> **next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。
### 插入意向锁
> 插入意向锁名字虽然有意向锁，但是它并**不是意向锁，它是一种特殊的间隙锁，属于行级别锁**。

* 如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

### MySQL死锁的发生情况


### 避免MySQL死锁
死锁的四个必要条件：
* 互斥条件
* 请求并保持条件
* 不剥夺条件
* 循环等待条件

在数据库层面，有两种策略通过「打破循环等待条件」来接触死锁状态：
* **设置事务等待锁的超时时间**：超过时间则事务回滚；
* **开启主动死锁检测**：主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。

# MySQL日志
> undo log、 redo log、 binlog

