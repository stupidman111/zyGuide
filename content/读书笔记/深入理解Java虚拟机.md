
# 第二章 Java内存区域与内存溢出异常

## 运行时数据区域
* 程序计数器：
	* 该区域是每个线程所私有的；
	* Java字节码解释器通过改变这个计数器的值，实现分支、循环、跳转、异常处理、线程切换等基础功能；
	* 不会发生任何OutOfMemoryError；
* 虚拟机栈：
	* 该区域是每个线程所私有的；
	* 调用一个方法会产生一个栈帧并压入虚拟机栈，方法的调用与返回对应着栈帧在虚拟机栈中的入栈与出栈，每个栈帧中包含：局部变量表、操作数栈、动态连接、返回地址（方法出口）等信息；
	* 局部变量表中存放了编译期可知的各种Java基本数据类型，包括boolean、byte、char、short、int、long、float、double以及reference对象引用和returnAddress返回地址；
	* 当虚拟机不允许虚拟机栈动态扩展时，线程调用方法过多时，虚拟机栈可能会触发StackOverflowError；
	* 当虚拟机允许虚拟机栈动态扩展时，虚拟机栈扩展时无法申请足够的内存时可能会触发OutOfMemoryError；
* 本地方法栈：
	* 该区域是各个线程所共享的；
	* 与虚拟机栈类似，不过虚拟机栈是执行Java方法的栈，本地方法栈是执行native方法的栈；
* Java堆：
	* 该区域是各个线程所共享的；
	* 垃圾收集器管理的内存区域；
	* 除栈上分配、标量替换优化手段之外的数据，大部分对象实例和数组都在堆上分配；
	*  一般虚拟机都将堆设置为可动态扩展的，当堆内存不够，且不能再动态扩展时，会抛出OutOfMemoryError异常；
* 方法区：
	* 该区域是各个线程所共享的；
	* 永久代：JDK 1.8之前，HotSpot虚拟机使用永久代来实现方法区；
	* 元空间：JDK 1.8开始，方法区主流都是采用元空间实现；
	* 方法区的内存回收目标主要针对（运行时）常量池的回收和对类型的卸载； 
	* 若方法区无法满足新的内存分配需求，会抛出OutOfMemoryError异常；
* 运行时常量池：
	* 方法区的一部分，因此也是各个线程所共享的；
	* Class文件中的常量池表（用于存放编译器所生成的各种字面量和符号引用）将在类加载后存放到方法区的运行时常量池中；（Class文件中包含类的版本、字段、方法、接口、常量池表等信息）
	* 符号引用翻译出来的直接引用也存储在字符串常量池中；
	* 运行期间也可以将新的常量放入到池中，比如使用`String::intern()`方法；
	* 属于方法区的一部分，也会抛出OutOfMemoryError异常；
* 直接内存：
	* 并不是虚拟机运行时数据区的一部分；
	* 可通过NIO的方式直接操作本机内存，提高性能；
## 对象
* 对象的创建：
	* 当虚拟机执行到一条new指令时，回先检查new指令后面所跟的参数能否在运行时常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析、初始化过，如果没有那么必须先执行响应的类加载过程；
	* 类加载检查完成后，需要为该对象分配内存，对象所需内存在类加载过程完成后就可以确定，根据Java堆中内存是否划分规整，有指针碰撞和空闲列表两种分配方式：
		* Java堆是否划分规整与所采用的垃圾收集器是否带有空间压缩整理能力决定；
		* 指针碰撞：Java堆内存是规整的，使用的过内存放在一边，未使用过的内存放在另一边，中间维护着一个指针，分配内存就是将该指针往未使用过的内存方向移动；
		* 空闲列表：Java堆内存是不规则的，使用空闲列表来记录尚未分配过的内存，分配内存需要在空闲列表上找到一块大小足够的内存来分配；
	* 为对象所分配到的内存空间初始化零值，保证对象的实例字段可以不赋初值就直接使用；
	* 设置对象头的信息（当前对象是哪个类的实例、如何才能找到类的元数据信息、对象的hash值、对象的GC年龄、等等）；
	* 执行<init>函数，即构造函数；
* 对象的内存布局：
	* 对象头：
		* MarkWord：存储对象的哈希码、GC年龄、锁状态、线程持有的锁、偏向线程ID、偏向时间戳等等；
		* 类型指针：指向他的类型元数据的指针；
		* 数组长度：如果不是数组对象，就没有该字段；
	* 对象体：子类本身定义的、从父类继承的字段信息都会存在这里；
	* 填充字段：保证对象是8字节的整数倍（对象头大小是固定的，因此填充字段主要用来针对对象体进行填充的）
* 对象的访问定位：
	* 句柄：
		* reference指向句柄池中的一个句柄，句柄中保存指向对象实例数据的指针和执行对象类型数据的指针；
		* 对象被移动时只会改变句柄中的对象实例数据指针，不会改变reference；
	* 直接指针：
		* reference直接指向对象实例数据，对象实例数据中包含一个指向对象类型数据的指针；
		* 使用直接指针可以在访问对象实例数据时节省一次指针定位的开销；


# 第三章 垃圾回收器与内存分配策略

## 对象回收

* 对象已死（可回收）的判断：
	* 引用计数法：
		* 原理：在对象中添加一个引用计数器，每当一个地方引用该对象时，计数器+1，每当一个对该对象的引用失效时，计数器-1，计数器为0的对象就是不可能再使用的；
		* 存在的问题：存在对象直接相互循环引用的问题(A、B中的成员互相指向对方)；
	* 可达性分析法：
		* 原理：一系列被称为`GC Roots`的根对象构成一个起始节点集，如果某个对象到`GC Roots`对象之间没有任何引用链相连，即从GC Roots到该对象是不可达的，则证明此对象是不再使用的；
		* GC Roots对象包括：
			* 在Java虚拟机栈中引用的对象
			* 本地方法栈中引用的对象
			* 类的静态属性引用的对象
			* 方法区中常量引用的对象
			* Java虚拟机内部的引用，如常驻的异常对象、系统类加载器等；
			* 所有被同步锁（synchronized关键字）持有的对象；
			* ...
		
* Java中的引用分类：
	* 强引用：即代码中普通存在的引用赋值；只要强引用关系存在，对象就不会被回收；
	* 软引用：用来描述一些还有用、但不是必须的对象；只被软引用所关联的对象，在系统将要发生内存溢出异常前，会对软引用的对象加入回收范围进行二次回收，若还是没有足够的内存，才会抛出内存溢出异常；可以使用SoftReference类来实现软引用；
	* 弱引用：用来描述那些非必须对象；被弱引用关联的对象只能生存到下一次垃圾回收发生为止，当垃圾回收器开始工作时，无论内存是否充足，都会回收掉弱引用的对象；可以使用WeakReference类来实现弱引用；
	* 虚引用：也称为幽灵引用或者幻影引用；一个对象是否被虚引用，与其生命周期没有任何关系，也无法通过虚引用来获取一个对象实例；通常为一个对象设置虚引用的唯一目的是在对象被垃圾回收时能够得到一个通知；可以使用PhantomReference来实现虚引用；

* `finalize()方法`：一个对象的死亡至少要经过两次标记过程
	* 若对对象进行可达性分析法后发现它与GC Roots对象之间不存在引用链，那么该对象会被第一次标记；
	* 随后进行一次筛选，筛选的条件是该对象是否有用执行`finalize()`方法，若对象没有重写`finalize()`方法，或者已经被虚拟机调用过该方法，那么就认为没有必要执行该方法；
	* 若需要执行finalize方法，则会将该对象加入到一条F-Queue的队列中，由专门的线程去执行该队列中对象的finalize方法；
	* 如果在对象的finalize方法中，能够重新与GC Roots引用链关联上，那么就不会被回收，否则就会被回收；

* 方法区的回收：
	*  方法区的回收主要回收两部分内容：废弃的常量 和 不再使用的类型；
	* 判断一个常量是否废弃：
		* 没有任何字符串对象引用这个常量，虚拟机也没有其他地方引用这个常量；
	* 判断一个类型不在使用：
		* 该类型的所有对象都已经被回收，即Java堆中不存在任何该类以及派生子类的实例；
		* 加载该类的类加载器已经被回收；
		* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；

## 垃圾回收

* 分代收集，建立在三个假说之上：
	* 弱分代假说：绝大多数对象都是朝生夕灭的；
	* 强分代假说：熬过越多次垃圾回收的对象就越难以消亡；
	* 跨代引用假说：跨代引用相对于同代引用占极少数；

* 回收类型：
	* Partial GC---部分收集:
		* 新生代收集（Minor GC / Young GC）：只针对新生代的垃圾收集
		* 老年代收集（Major GC / Old GC）：只针对老年代的垃圾收集（目前只有CMS垃圾回收器有单独收集老年代的行为）
		* 混合收集（Mixed GC）：针对整个新生代和部分老年代进行的垃圾收集
	* Full GC---整堆收集：针对整个Java堆和方法区的垃圾收集

* 垃圾收集算法：
	* 标记-清除算法：分为标记、清除两个阶段：
		* 标记阶段：根据对象死亡判定方法，标记出所有存活的对象；
		* 清除阶段：回收掉所有死亡的对象的内存；
		* 问题：存在内存碎片
	* 标记-复制算法：
		* 原理：将Java堆划分为两个区域，每次只使用其中一个区域，当用完了，就对区域所有对象进行标记，将存活的对象移动到另一个区域，再调换两个区域的性质；
		* 分析：对于多数对象都是可回收的情况下，移动的对象数量大；对于少数对象可回收的情况下，移动的对象数量小；
		* 问题：空间浪费太大；
		* 分区策略：1个`Eden`区、两个`Survivor`区`，Eden比Survivor是8:1的关系；每次只使用`Eden`和其中一个`Survivor`；垃圾回收时将存活的对象都移动到另一个`Survivor`上，然后再使用这个`Survivor`与`Eden`进行空间分配；
		* 分配担保机制：当Survivor不足以容纳一次`Minor GC`之后存活的对象之后，需要依赖老年代进行一个分配担保，使这些对象直接进入老年代；
	* 标记-整理算法：
		* 标记阶段：标记所有存活对象；
		* 整理阶段：将被标记的对象往内存空间的一段移动

## 垃圾回收算法前置知识

* 根节点枚举
* 安全点
* 安全区域
* 记忆集与卡表
* 写屏障
* 并发的可达性分析

## 垃圾回收器

