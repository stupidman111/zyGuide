
# 第二章 Java内存区域与内存溢出异常

## 运行时数据区域
* 程序计数器：
	* 该区域是每个线程所私有的；
	* Java字节码解释器通过改变这个计数器的值，实现分支、循环、跳转、异常处理、线程切换等基础功能；
	* 不会发生任何OutOfMemoryError；
* 虚拟机栈：
	* 该区域是每个线程所私有的；
	* 调用一个方法会产生一个栈帧并压入虚拟机栈，方法的调用与返回对应着栈帧在虚拟机栈中的入栈与出栈，每个栈帧中包含：局部变量表、操作数栈、动态连接、返回地址（方法出口）等信息；
	* 局部变量表中存放了编译期可知的各种Java基本数据类型，包括boolean、byte、char、short、int、long、float、double以及reference对象引用和returnAddress返回地址；
	* 当虚拟机不允许虚拟机栈动态扩展时，线程调用方法过多时，虚拟机栈可能会触发StackOverflowError；
	* 当虚拟机允许虚拟机栈动态扩展时，虚拟机栈扩展时无法申请足够的内存时可能会触发OutOfMemoryError；
* 本地方法栈：
	* 该区域是各个线程所共享的；
	* 与虚拟机栈类似，不过虚拟机栈是执行Java方法的栈，本地方法栈是执行native方法的栈；
* Java堆：
	* 该区域是各个线程所共享的；
	* 垃圾收集器管理的内存区域；
	* 除栈上分配、标量替换优化手段之外的数据，大部分对象实例和数组都在堆上分配；
	*  一般虚拟机都将堆设置为可动态扩展的，当堆内存不够，且不能再动态扩展时，会抛出OutOfMemoryError异常；
* 方法区：
	* 该区域是各个线程所共享的；
	* 永久代：JDK 1.8之前，HotSpot虚拟机使用永久代来实现方法区；
	* 元空间：JDK 1.8开始，方法区主流都是采用元空间实现；
	* 方法区的内存回收目标主要针对（运行时）常量池的回收和对类型的卸载； 
	* 若方法区无法满足新的内存分配需求，会抛出OutOfMemoryError异常；
* 运行时常量池：
	* 方法区的一部分，因此也是各个线程所共享的；
	* Class文件中的常量池表（用于存放编译器所生成的各种字面量和符号引用）将在类加载后存放到方法区的运行时常量池中；（Class文件中包含类的版本、字段、方法、接口、常量池表等信息）
	* 符号引用翻译出来的直接引用也存储在字符串常量池中；
	* 运行期间也可以将新的常量放入到池中，比如使用`String::intern()`方法；
	* 属于方法区的一部分，也会抛出OutOfMemoryError异常；
* 直接内存：
	* 并不是虚拟机运行时数据区的一部分；
	* 可通过NIO的方式直接操作本机内存，提高性能；
## 对象
* 对象的创建：
	* 当虚拟机执行到一条new指令时，回先检查new指令后面所跟的参数能否在运行时常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析、初始化过，如果没有那么必须先执行响应的类加载过程；
	* 类加载检查完成后，需要为该对象分配内存，对象所需内存在类加载过程完成后就可以确定，根据Java堆中内存是否划分规整，有指针碰撞和空闲列表两种分配方式：
		* Java堆是否划分规整与所采用的垃圾收集器是否带有空间压缩整理能力决定；
		* 指针碰撞：Java堆内存是规整的，使用的过内存放在一边，未使用过的内存放在另一边，中间维护着一个指针，分配内存就是将该指针往未使用过的内存方向移动；
		* 空闲列表：Java堆内存是不规则的，使用空闲列表来记录尚未分配过的内存，分配内存需要在空闲列表上找到一块大小足够的内存来分配；
	* 为对象所分配到的内存空间初始化零值，保证对象的实例字段可以不赋初值就直接使用；
	* 设置对象头的信息（当前对象是哪个类的实例、如何才能找到类的元数据信息、对象的hash值、对象的GC年龄、等等）；
	* 执行<init>函数，即构造函数；
* 对象的内存布局：
	* 对象头：
		* MarkWord：存储对象的哈希码、GC年龄、锁状态、线程持有的锁、偏向线程ID、偏向时间戳等等；
		* 类型指针：指向他的类型元数据的指针；
		* 数组长度：如果不是数组对象，就没有该字段；
	* 对象体：子类本身定义的、从父类继承的字段信息都会存在这里；
	* 填充字段：保证对象是8字节的整数倍（对象头大小是固定的，因此填充字段主要用来针对对象体进行填充的）
* 对象的访问定位：
	* 句柄：
		* reference指向句柄池中的一个句柄，句柄中保存指向对象实例数据的指针和执行对象类型数据的指针；
		* 对象被移动时只会改变句柄中的对象实例数据指针，不会改变reference；
	* 直接指针：
		* reference直接指向对象实例数据，对象实例数据中包含一个指向对象类型数据的指针；
		* 使用直接指针可以在访问对象实例数据时节省一次指针定位的开销；
