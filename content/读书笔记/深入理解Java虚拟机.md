
# 第二章 Java内存区域与内存溢出异常

## 运行时数据区域
* 程序计数器：
	* 该区域是每个线程所私有的；
	* Java字节码解释器通过改变这个计数器的值，实现分支、循环、跳转、异常处理、线程切换等基础功能；
	* 不会发生任何OutOfMemoryError；
* 虚拟机栈：
	* 该区域是每个线程所私有的；
	* 调用一个方法会产生一个栈帧并压入虚拟机栈，方法的调用与返回对应着栈帧在虚拟机栈中的入栈与出栈，每个栈帧中包含：局部变量表、操作数栈、动态连接、返回地址（方法出口）等信息；
	* 局部变量表中存放了编译期可知的各种Java基本数据类型，包括boolean、byte、char、short、int、long、float、double以及reference对象引用和returnAddress返回地址；
	* 当虚拟机不允许虚拟机栈动态扩展时，线程调用方法过多时，虚拟机栈可能会触发StackOverflowError；
	* 当虚拟机允许虚拟机栈动态扩展时，虚拟机栈扩展时无法申请足够的内存时可能会触发OutOfMemoryError；
* 本地方法栈：
	* 该区域是各个线程所共享的；
	* 与虚拟机栈类似，不过虚拟机栈是执行Java方法的栈，本地方法栈是执行native方法的栈；
* Java堆：
	* 该区域是各个线程所共享的；
	* 垃圾收集器管理的内存区域；
	* 除栈上分配、标量替换优化手段之外的数据，大部分对象实例和数组都在堆上分配；
	*  一般虚拟机都将堆设置为可动态扩展的，当堆内存不够，且不能再动态扩展时，会抛出OutOfMemoryError异常；
* 方法区：
	* 该区域是各个线程所共享的；
	* 永久代：JDK 1.8之前，HotSpot虚拟机使用永久代来实现方法区；
	* 元空间：JDK 1.8开始，方法区主流都是采用元空间实现；
	* 方法区的内存回收目标主要针对（运行时）常量池的回收和对类型的卸载； 
	* 若方法区无法满足新的内存分配需求，会抛出OutOfMemoryError异常；
* 运行时常量池：
	* 方法区的一部分，因此也是各个线程所共享的；
	* Class文件中的常量池表（用于存放编译器所生成的各种字面量和符号引用）将在类加载后存放到方法区的运行时常量池中；（Class文件中包含类的版本、字段、方法、接口、常量池表等信息）
	* 符号引用翻译出来的直接引用也存储在常量池中；
	* 运行期间也可以将新的常量放入到池中，比如使用`String::intern()`方法；
	* 属于方法区的一部分，也会抛出OutOfMemoryError异常；
* 直接内存：
	* 并不是虚拟机运行时数据区的一部分；
	* 可通过NIO的方式直接操作本机内存，提高性能；
## 对象
* 对象的创建：
	* 当虚拟机执行到一条new指令时，回先检查new指令后面所跟的参数能否在运行时常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析、初始化过，如果没有那么必须先执行响应的类加载过程；
	* 类加载检查完成后，需要为该对象分配内存，对象所需内存在类加载过程完成后就可以确定，根据Java堆中内存是否划分规整，有指针碰撞和空闲列表两种分配方式：
		* Java堆是否划分规整与所采用的垃圾收集器是否带有空间压缩整理能力决定；
		* 指针碰撞：Java堆内存是规整的，使用的过内存放在一边，未使用过的内存放在另一边，中间维护着一个指针，分配内存就是将该指针往未使用过的内存方向移动；
		* 空闲列表：Java堆内存是不规则的，使用空闲列表来记录尚未分配过的内存，分配内存需要在空闲列表上找到一块大小足够的内存来分配；
	* 为对象所分配到的内存空间初始化零值，保证对象的实例字段可以不赋初值就直接使用；
	* 设置对象头的信息（当前对象是哪个类的实例、如何才能找到类的元数据信息、对象的hash值、对象的GC年龄、等等）；
	* 执行<init>函数，即构造函数；
* 对象的内存布局：
	* 对象头：
		* MarkWord：存储对象的哈希码、GC年龄、锁状态、线程持有的锁、偏向线程ID、偏向时间戳等等；
		* 类型指针：指向他的类型元数据的指针；
		* 数组长度：如果不是数组对象，就没有该字段；
	* 对象体：子类本身定义的、从父类继承的字段信息都会存在这里；
	* 填充字段：保证对象是8字节的整数倍（对象头大小是固定的，因此填充字段主要用来针对对象体进行填充的）
* 对象的访问定位：
	* 句柄：
		* reference指向句柄池中的一个句柄，句柄中保存指向对象实例数据的指针和执行对象类型数据的指针；
		* 对象被移动时只会改变句柄中的对象实例数据指针，不会改变reference；
	* 直接指针：
		* reference直接指向对象实例数据，对象实例数据中包含一个指向对象类型数据的指针；
		* 使用直接指针可以在访问对象实例数据时节省一次指针定位的开销；


# 第三章 垃圾回收器与内存分配策略

## 对象回收

* 对象已死（可回收）的判断：
	* 引用计数法：
		* 原理：在对象中添加一个引用计数器，每当一个地方引用该对象时，计数器+1，每当一个对该对象的引用失效时，计数器-1，计数器为0的对象就是不可能再使用的；
		* 存在的问题：存在对象直接相互循环引用的问题(A、B中的成员互相指向对方)；
	* 可达性分析法：
		* 原理：一系列被称为`GC Roots`的根对象构成一个起始节点集，如果某个对象到`GC Roots`对象之间没有任何引用链相连，即从GC Roots到该对象是不可达的，则证明此对象是不再使用的；
		* GC Roots对象包括：
			* 在Java虚拟机栈中引用的对象
			* 本地方法栈中引用的对象
			* 类的静态属性引用的对象
			* 方法区中常量引用的对象
			* 所有被同步锁（synchronized关键字）持有的对象；
			* Java虚拟机内部的引用，如常驻的异常对象、系统类加载器等；
			* ...
		
* Java中的引用分类：
	* 强引用：GC Roots对象所引用的对象就是强引用；只要强引用关系存在，对象就不会被回收；
	* 软引用：用来描述一些还有用、但不是必须的对象；只被软引用所关联的对象，在系统将要发生内存溢出异常前，会对软引用的对象加入回收范围进行二次回收，若还是没有足够的内存，才会抛出内存溢出异常；可以使用SoftReference类来实现软引用；
	* 弱引用：用来描述那些非必须对象；被弱引用关联的对象只能生存到下一次垃圾回收发生为止，当垃圾回收器开始工作时，无论内存是否充足，都会回收掉弱引用的对象；可以使用WeakReference类来实现弱引用；
	* 虚引用：也称为幽灵引用或者幻影引用；一个对象是否被虚引用，与其生命周期没有任何关系，也无法通过虚引用来获取一个对象实例；通常为一个对象设置虚引用的唯一目的是在对象被垃圾回收时能够得到一个通知；可以使用PhantomReference来实现虚引用；

* `finalize()方法`：一个对象的死亡至少要经过两次标记过程
	* 若对对象进行可达性分析法后发现它与GC Roots对象之间不存在引用链，那么该对象会被第一次标记；
	* 随后进行一次筛选，筛选的条件是该对象是否有用执行`finalize()`方法，若对象没有重写`finalize()`方法，或者已经被虚拟机调用过该方法，那么就认为没有必要执行该方法；
	* 若需要执行finalize方法，则会将该对象加入到一条F-Queue的队列中，由专门的线程去执行该队列中对象的finalize方法；
	* 如果在对象的finalize方法中，能够重新与GC Roots引用链关联上，那么就不会被回收，否则就会被回收；

* 方法区的回收：
	*  方法区的回收主要回收两部分内容：废弃的常量 和 不再使用的类型；
	* 判断一个常量是否废弃：
		* 没有任何字符串对象引用这个常量，虚拟机也没有其他地方引用这个常量；
	* 判断一个类型不再使用：
		* 该类型的所有对象都已经被回收，即Java堆中不存在任何该类以及派生子类的实例；
		* 加载该类的类加载器已经被回收；
		* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；

## 垃圾回收

* 分代收集，建立在三个假说之上：
	* 弱分代假说：绝大多数对象都是朝生夕灭的；
	* 强分代假说：熬过越多次垃圾回收的对象就越难以消亡；
	* 跨代引用假说：跨代引用相对于同代引用占极少数；

* 回收类型：
	* Partial GC---部分收集:
		* 新生代收集（Minor GC / Young GC）：只针对新生代的垃圾收集
		* 老年代收集（Major GC / Old GC）：只针对老年代的垃圾收集（目前只有CMS垃圾回收器有单独收集老年代的行为）
		* 混合收集（Mixed GC）：针对整个新生代和部分老年代进行的垃圾收集
	* Full GC---整堆收集：针对整个Java堆和方法区的垃圾收集

* 垃圾收集算法：
	* 标记-清除算法：分为标记、清除两个阶段：
		* 标记阶段：根据对象死亡判定方法，标记出所有存活的对象；
		* 清除阶段：回收掉所有死亡的对象的内存；
		* 问题：存在内存碎片
	* 标记-复制算法：
		* 原理：将Java堆划分为两个区域，每次只使用其中一个区域，当用完了，就对区域所有对象进行标记，将存活的对象移动到另一个区域，再调换两个区域的性质；
		* 分析：对于多数对象都是可回收的情况下，移动的对象数量大；对于少数对象可回收的情况下，移动的对象数量小；
		* 问题：空间浪费太大；
		* 分区策略：1个`Eden`区、两个`Survivor`区`，Eden比Survivor是8:1的关系；每次只使用`Eden`和其中一个`Survivor`；垃圾回收时将存活的对象都移动到另一个`Survivor`上，然后再使用这个`Survivor`与`Eden`进行空间分配；
		* 分配担保机制：当Survivor不足以容纳一次`Minor GC`之后存活的对象之后，需要依赖老年代进行一个分配担保，使这些对象直接进入老年代；
	* 标记-整理算法：
		* 标记阶段：标记所有存活对象；
		* 整理阶段：将被标记的对象往内存空间的一段移动

## 垃圾回收算法前置知识

* 根节点枚举
* 安全点
* 安全区域
* 记忆集与卡表
* 写屏障
* 并发的可达性分析

## 垃圾回收器
> ...

* Serial 垃圾回收器：
	* Serial垃圾回收器是一种单线程工作的垃圾回收器（这里的单线程主要是强调它工作时有一段STW时间以暂停其他工作线程的执行）
	* Serial一般用于新生代垃圾回收
	* Serial可以与CMS搭配使用：
		* 新生代使用Serial进行单线程执行标记-复制算法的垃圾回收；
		* 老年代使用CMS进行........
* Serial Old 垃圾回收器：
	* Seria Old垃圾回收器是Serial垃圾回收器的老年代版本
	* 同样是一种单线程垃圾回收器；
	* Serial 与 Serial Old通常搭配使用，
		* Serial负责在新生代采用`标记-复制`算法进行垃圾回收，
		* Serial Old负责在老年代采用`标记-整理`算法进行垃圾回收；
	* Serial Old还可以作为CMS收集器发生失败时的后备收集器；


* ParNew 垃圾回收器：
	* ParNew是Serial的多线程并行版本；
	* ParNew一般用于新生代垃圾回收
	* 在单核心环境下，ParNew绝对不会比Serial有更好的效果，因为ParNew多线程需要切换开销；
	* ParNew可以与Serial Old进行组合：
		* 新生代使用ParNew进行多线程并行执行标记-复制算法的垃圾回收；
		* 老年代使用Serial Old进行单线程执行标记-整理算法的垃圾回收；
	* ParNew可以与CMS进行组合：
		* 新生代使用ParNew进行多线程并行执行标记-复制算法的垃圾回收；
		* 老年代使用CMS进行...



* Parallel Scavenge 垃圾回收器---吞吐量优先收集器
	* Parallel Scavenge是一种多线程并行收集的基于标记-复制算法的垃圾回收器；
	* Parallel Scavenge的关注点在于达到一个可控制的吞吐量；所谓吞吐量是处理器用于执行用户代码的实现与处理器整体消耗时间的比值；通常情况下，吞吐量越高，执行效率越高；
	* Parallel Scavenge提供了用于控制最大垃圾回收暂停时间STW的参数--`-XX:MaxGCPauseMillis`；
	* Parallel Scavenge提供了用于直接设置吞吐量大小的参数--`-XX:GCTimeRatio`；


* Parallel Old 垃圾回收器：
	* Parallel Old是Parallel Scavenge的老年代版本，一种多线程并行收集的基于标记-整理算法的垃圾回收器；

* CMS 垃圾回收器---并发低停顿收集器---Concurrent-Mark-Sweep
	* 一种以获取最短回收停顿时间为目标的垃圾回收器；
	* CMS是基于标记-清除算法的老年代垃圾回收器；
	* 整个过程分为四个步骤：
		* 初始标记阶段：需要STW，只标记GC Roots对象直接关联的对象；
		* 并发标记阶段：不需要暂停用户线程，标记GC Roots链上的所有对象；
		* 重新标记阶段：需要STW，修正并发标记阶段期间用户线程继续运作而产生变动的标记；
		* 并发清除阶段：不需要暂停用户线程，负责回收掉标记阶段被判定为已死亡的对象；
	* 缺点：
		* CMS垃圾回收器对处理器资源非常敏感：CMS默认启动的回收线程数是`(处理器核心数 + 3) / 4`，也就是说，当处理器核心数大于等于4时，CMS并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，当处理器核心数不足四个时，CMS对于用户程序的影响又会变得很大；
		* CMS无法处理浮动垃圾，可能会出现并发失败而导致另一次完全STW的FULL GC的产生：浮动垃圾是指CMS的并发标记和并发清理阶段，由于用户线程与垃圾回收线程并发执行，而由用户线程动态产生的垃圾，CMS无法在当次垃圾回收时清理掉，只能留到下一次垃圾回收时清理；因为垃圾回收阶段用户线程还需要正常执行，所以必须预留一部分内存空间供用户线程申请，这种预留的空间占比也是不好把握的，若无法满足给新对象分配空间，就会出现`并发失败`，这时需要启动预备方案，暂停所有用户线程，临时启动Serial Old收集器来对老年代进行收集；
		* CMS是基于`标记-清除`算法的垃圾回收器，因此会有内存碎片的存在；
	* CMS是老年代垃圾回收器（可使用Serial Old做备案），新生代可搭配Serial、ParNew；


* Garbage First 垃圾回收器（G1）：
	* G1是一款主要面向服务端应用的垃圾回收器；
	* `停顿时间模型`垃圾回收器：指定一个长度为M毫秒的时间片段内，消耗在垃圾回收上的时间大概率不超过N毫秒；
	* `G1垃圾回收器的Mixed GC模式`：G1面向堆内存任何部分来组成回收集（Collection Set -- CSet）进行回收，衡量标准不再是属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大；
	* G1特点：
		* G1不再以固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region）；
		* 每一个Region都可以根据需要，扮演新生代的Eden区、Survivor区或者老年代空间，G1根据扮演不同角色的Region采用不同的策略进行处理；
		* Region的大小可以通过参数`-XX:G1HeapRegionSize`设置，范围在1MB~32MB，且为2的n次幂；
		* G1中还有一类特殊的Humongous区域，专门用来存储大对象，G1认为只要一个对象大小超过了Region的一半，就属于大对象；
		* 对于超过整个Region容量的大对象，会存放在N个连续的Humongous Region中，G1将Humongous Region作为老年代的一部分来看待；
		* G1中保留了新生代、老年代的分代概念，但它们不再是连续的，而是由若干个不需要连续的Region组成；
		* G1将Region作为单次回收的最小单元，每次收集的大小都是Region的整数倍，可以避免在整个Java堆中进行全区域的垃圾收集；
		* G1会跟踪各个Region中垃圾回收的价值大小（价值即回收得到的空间大小和回收所需时间的经验值），然后在后台维护一个优先级列表，每次根据用户设定的`收集停顿时间`优先处理回收价值收益最大的一些Region；
	* G1收集器运作过程：
		* 初始标记：该阶段需要暂停用户线程，仅对GC Roots直接关联的对象做标记，修改Region中名为TAMS的指针，让下一阶段用户线程与GC线程并发时能够在可用的Region中分配新对象；
		* 并发标记：该阶段可与用户线程并发执行，对所有GC Roots引用链上的对象做扫描，找出要回收的对象，并且需要处理在快照记录下并发时有引用变动的对象；
		* 最终标记：该阶段需要暂停用户线程，用于处理并发阶段结束后遗留下来的快照记录
		* 筛选回收：该阶段需要暂停用户线程，对各个Region的回收价值和成本进行排序，然后将决定回收的Region中存活的对象赋值到空的Region上，再清理掉整个旧Region的全部空间；
	* 根据G1垃圾回收的过程，可以得到：G1从整体上看是基于`标记-整理`算法实现的，而从局部上看G1是基于`标记-复制`算法实现的；因此G1运行期间不会产生内存碎片；
	* G1实现上解决的问题：
		* 将Java堆分成多个独立的Region中，Region中存在的跨Region引用对象如何解决？
		* 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？
		* 怎样建立可靠的`停顿预测模型`？

## 低延迟垃圾收集器
> ...

* Shenandoah 垃圾回收器
* ZGC 垃圾回收器


## 内存分配与回收策略
> 可以使用`-XX:+PrintGCDetails`参数打印收集器日志；


* 对象优先在Eden区分配：大多数情况下，对象优先在新生代`Eden`区分配，当`Eden`区没有足够空间进行分配时，虚拟机将发起一次`Minor GC`；
* 大对象直接进入老年代：大对象直接进入老年代，通过设置虚拟机参数`-XX:PretenureSizeThreshold`可指定大于该设置值的对象直接在老年代分配，目的是避免在`Eden`区以及两个`Survivor`区之间频繁来回复制，产生大量的内存复制操作；
* 达到一定年龄的对象将移动至老年代：虚拟机给每个对象定义了一个对象年龄计数器，存储在对象头的MarkWord字段中，对象通常在Eden区内进行分配，若第一次Minor GC时对象任然存活，且能够被Survivor容纳的话，该对象会被移动到`Survivor`区，并将其年龄+1；往后对象每在Survivor区中熬过一次Minor GC，对象的年龄就+1；当对象的年龄到达了设定的阈值，就会被移动到老年代中，该阈值默认为15，可以通过参数`-XX:MaxTenuringThreshold`设置；
* 虚拟机的对象年龄动态判定机制：为适应不同程序的内存情况，虚拟机并不是永远要求新生代中的对象到达阈值年龄才会进入老年代；若Survivor区中相同年龄的对象所占的空间大小达到了Survivor区的一半，那么年龄大于或等于该年龄的对象就会直接移动至老年代，而无须等到年龄所设定的阈值；
* 空间分配担保机制：只要老年代的连续可分配空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC（只回收新生代），否则会进行Full GC（回收新生代、老年代）；


# 第六章 类文件结构
> 应当追求：各种语言-->经过自己的编译器-->生成相同指令集的.Class文件-->由VM执行
> 
> 即各种语言都能够跑在同一个虚拟机上。

## Class类文件的结构
> 总而言之，一个Class文件所描述的类的所有信息，都以二进制流的方式存储，并且这个二进制流中哪部分描述什么信息，都可以按照规定解读出来；

* Class文件
	* 一组以8个字节为基础单位的二进制流；
	* 采用结构体来存储数据，且结构体中只有两种类型数据：`无符号数`和`表`；
	* 无符号数：u1、u2、u4、u8分别代表1、2、4、8个字节的无符号数，无符号数可用来描述数字、索引引用、数量值、字符串值；
	* 表：由多个无符号数或者其他表作为数据结构的复合数据类型，表的命名都以`_info`结尾，`整个Class文件本质上也可以视为一张表`；

* 魔术：第1~4字节，u4
* 次版本号：第5、6字节，u2
* 主版本号：第7、8字节，u2
* 常量池：
	* 常量池入口字段：u2，代表常量池容量计数值；
	* 常量池：cp_info，用于存放`字面量`和`符号引用`，
		* 字面量：如文本字符串、被声明为final的常量值等；
		* 符号引用：
			* 被模块导出或者开发的包；
			* 类和接口的全限定名；
			* 字段的名称和描述符；
			* 方法的名称和描述符；
			* 方法句柄和方法类型；
			* 动态调用点和动态常量；
> Class文件中只有常量池的容量计数从1开始，其他表类型如接口索引集合、字段表集合、方法表集合容量计数都从0开始；
> 符号引用的作用：Class文件中不会保存各个方法、字段最终在内存中的布局信息（地址），这些字段、方法的符号引用必须经过虚拟机转换才能在内存中拥有内存地址，而当类加载时，才会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中；
* 访问标志：常量池结束后紧接着一个u2---两个字节代表访问标志；该标志用于识别：
	* 该Class是类还是接口；
	* 是否定义为public类；
	* 是否定义为abstract类型；
	* 若为类，是否被声明为final；
	* 等等；
* 类索引、父类索引、接口索引集合：
	* 类索引、父类索引：都是一个u2类型的数据：
		* 类索引确定该类的全限定名；
		* 父类索引确定该类的直接父类的全限定名，因为Java不允许多继承，所以父类索引只有一个，并且除了java.lang.Object类以外，其他所有类的父类索引都不为0；
	* 接口索引集合：一个u2类型的数据表（集合），u2表示后面跟的接口索引集合的计数：
		* 用于描述该类实现了哪些接口；
* 字段表集合：字段表集合之前是一个u2类型的数据表示后面的字段表集合的计数；
	* Java语言中的字段包括：类级变量、实例变量，但不包括方法内部声明的局部变量；
	* 每个字段的信息：
		* 字段的修饰符，用一个u2来表示，包括：
			* 字段的作用域：public、private、protected
			* 实例变量还是类变量：static
			* 可变性：final
			* 并发可见性：volatile
			* 序列化：transient
		* 字段的名称：对常量池的引用
		* 字段的描述符：对常量池的引用，描述字段的数据类型：基本数据类型、对象、数组
		* ...
* 方法表集合：方法表集合之前是一个u2类型的数据表示后面的方法表集合的计数；与字段表集合类似：
	* 方法的访问标志：
	* 方法的名称：对常量池的引用
	* 方法的描述符：对常量池的引用，包含方法的参数列表（数量、类型、顺序）和返回值
	* ...
* 属性表集合：...
	
  

## 字节码指令简介

