
# 第一章 并发编程的挑战
* 上下文切换
	* 任务从保存到再加载的过程就是一次上下文切换；
	* 减少上下文切换的方法：
		* 无锁并发编程：可以将数据的ID按照哈希算法进行取模分段，不同的线程处理不同段的数据；
		* CAS算法：Java的Atomic包使用CAS算法来更新数据，不需要加锁；
		* 使用最少线程：避免创建不必要的线程；
		* 使用协程：在单线程中实现多任务的调度，并维持多任务的切换。
* 死锁
	* 多个线程互相等待对方释放锁；
	* 避免死锁：
		* 避免一个线程同时获取多个锁；
		* 避免一个线程在锁内同时占有多个资源；
		* 使用定时锁，如`Lock.tryLock(timeOut)`方法；
		* 对于数据库锁，加锁、解锁必须在一个数据库连接内，否则会出现解锁失败的情况；
* 资源限制
	* 并发编程时，程序的执行受硬件资源或软件资源的限制；
	* 解决办法：
		* 对于硬件资源：使用集群；
		* 对于软件资源：将资源`池化`，使其能复用；
# 第二章 Java并发机制的底层实现原理
> volatile与synchronized

* `volatile`：
	* 轻量级的`synchronized`；
	* 保证`共享变量的可见性`，可见性：当一个线程修改一个共享变量时，其他线程能够读到这个修改的值；
	* 原理：volatile修饰的共享变量进行写操作时，汇编代码会多出一条含有`lock前缀`指令的代码，`lock前缀`指向在多核处理器下会发生：
		* 将当前处理器核心的Cache行数据写回到内存中；
		* 通知其他核心，若Cache中含有对应内存地址的数据则失效；
	* ...
* `synchronized`：
	* synchronized实现同步的基础是Java中每一个对象都可以作为锁，具体表现为：
		* synchronized作用于普通同步方法，锁的是当前实例对象；
		* synchronized作用于静态同步方法，锁的是当前类的Class对象；
		* synchronized作用于同步代码块，锁的是括号内配置的对象；
	* synchronized的实现原理是JVM基于进入、退出`Monitor`对象来实现方法同步和代码块同步：
		* 代码块同步使用`monitorenter`、`monitorexit`指令来实现，执行`moniterenter`即尝试获取对象对应的`Monitor`的所有权，即尝试获取对象的锁；
		* 方法同步使用
	* 