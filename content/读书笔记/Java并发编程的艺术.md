
# 第一章 并发编程的挑战
* 上下文切换
	* 任务从保存到再加载的过程就是一次上下文切换；
	* 减少上下文切换的方法：
		* 无锁并发编程：可以将数据的ID按照哈希算法进行取模分段，不同的线程处理不同段的数据；
		* CAS算法：Java的Atomic包使用CAS算法来更新数据，不需要加锁；
		* 使用最少线程：避免创建不必要的线程；
		* 使用协程：在单线程中实现多任务的调度，并维持多任务的切换。
* 死锁
	* 多个线程互相等待对方释放锁；
	* 避免死锁：
		* 避免一个线程同时获取多个锁；
		* 避免一个线程在锁内同时占有多个资源；
		* 使用定时锁，如`Lock.tryLock(timeOut)`方法；
		* 对于数据库锁，加锁、解锁必须在一个数据库连接内，否则会出现解锁失败的情况；
* 资源限制
	* 并发编程时，程序的执行受硬件资源或软件资源的限制；
	* 解决办法：
		* 对于硬件资源：使用集群；
		* 对于软件资源：将资源`池化`，使其能复用；
# 第二章 Java并发机制的底层实现原理
> volatile与synchronized

* `volatile`：
	* 轻量级的`synchronized`；
	* 保证`共享变量的可见性`，可见性：当一个线程修改一个共享变量时，其他线程能够读到这个修改的值；
	* 原理：volatile修饰的共享变量进行写操作时，汇编代码会多出一条含有`lock前缀`指令的代码，`lock前缀`指向在多核处理器下会发生：
		* 将当前处理器核心的Cache行数据写回到内存中；
		* 通知其他核心，若Cache中含有对应内存地址的数据则失效；
	* ...
* `synchronized`：
	* synchronized实现同步的基础是Java中每一个对象都可以作为锁，具体表现为：
		* synchronized作用于普通同步方法，锁的是当前实例对象；
		* synchronized作用于静态同步方法，锁的是当前类的Class对象；
		* synchronized作用于同步代码块，锁的是括号内配置的对象；
	* synchronized的实现原理是JVM基于进入、退出`Monitor`对象来实现方法同步和代码块同步：
		* 代码块同步使用`monitorenter`、`monitorexit`指令来实现，执行`moniterenter`即尝试获取对象对应的`Monitor`的所有权，即尝试获取对象的锁；
		* 方法同步使用
	* Java对象头：
		* MarkWord字段默认存储：对象的hash码（25bit），分代年龄（4bit），锁标志位（1bit偏向锁标识，2bit锁标志位）；
		* 锁的四种状态：无锁、偏向锁、轻量级锁、重量级锁；
		* 锁只能升级不能降级；
		* 偏向锁：
			* 线程访问同步块，会使用CAS在对象头的MarkWord中将偏向线程ID设置为自己的，并在栈帧中的锁记录中存储偏向线程ID；
			* 之后该线程进入和退出该同步块时，不需要使用CAS来加锁和解锁，只需要测试MarkWord中的偏向线程ID是否为当前线程；
				* 若测试成功，则表示线程已经获取锁（重入）；
				* 若测试失败，则需要再测试一下MarkWord中偏向标识是否为1，即当前是否为偏向锁：
					* 若不是，表示当前是其他锁状态，则使用CAS竞争锁；
					* 若是，则使用CAS尝试将对象头的偏向线程ID指向当前线程，若修改失败则晋升为轻量级锁。
			* 当其他线程创建竞争偏向锁时，持有偏向锁的线程才会释放锁。具体地，先暂停持有偏向锁的线程，然后检查该线程是否存活；
				* 若不存活，则将MarkWord设置为无锁状态；
				* 若存活，需要解锁，要么将MarkWord的偏向线程ID偏向其他线程，要么恢复到无锁或者标记对象不适合继续作为偏向锁（偏向锁撤销），【需要升级到轻量级锁】 
			* 最后唤醒偏向锁撤销的线程；
		* 轻量级锁：
			* 加锁：线程执行同步块之前，JVM在当前线程栈帧中创建用于存储锁记录的空间，并将对象头中的MarkWord复制到锁记录中，称为`Dispaced MarkWord`然后线程尝试用CAS将对象头的MardWord替换为指向本线程的锁记录的指针；
				* 成功：获得锁；
				* 失败：表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁
			* 解锁：线程使用CAS将锁记录中的Dispaced MarkWord替换回到对象头；
				* 若成功，表示当前没有锁竞争（没有其他线程自旋获取锁）；
				* 若失败，当前存在锁竞争，锁膨胀为重量级锁；
		* 锁升级流程：
			* 当没有线程访问同步块时，锁对象处于无锁状态，锁对象的MarkWord字段为`25bit HashCode + 4bit对象分代年龄 + 1bit是否偏向锁 + 2bit锁标志位`，其中1bit偏向锁位为0，2bit锁标志位为01；
			* 当第一个线程访问同步块时，锁对象会偏向该线程，JVM将锁对象的MarkWord的偏向线程ID会被设为当前线程ID，是否偏向锁标志位为1，锁标志位为01。之后若没有其他线程竞争的话，线程再进入同步块时就只需要检查一下锁对象的偏向线程ID是否为自己即可；如果有其他线程尝试获取锁，则会撤销偏向锁，升级为轻量级锁；
			* 轻量级锁需要使用CAS的方式来尝试获取，当有多个线程紧竞争同一个锁对象时，轻量级锁会膨胀为重量级锁；
			* 重量级锁会将线程挂起，进入阻塞状态，以保证同步的正确性；