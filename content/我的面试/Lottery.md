# 项目相关

## 分支顺序
```text
lottery-init-project
lottery-build-rpc-framework
lottery-design-tables
lottery-coding-strategy
lottery-config-activity
```

## domain层各领域
```text
strategy---抽奖策略，根据具体抽奖请求进行抽奖，得到一个奖品信息
award---奖品方法，根据奖品信息，执行奖品发放（包括落库等等）
activity---活动配置，包括活动创建、活动领取、活动的状态变更
support--提供ID生成，包括雪花算法、随机数、日期拼接三种ID生成方式
```
## 库表设计
- 活动配置，activity：提供活动的基本配置
- 策略配置，strategy：用于配置抽奖策略，概率、玩法、库存、奖品
- 策略明细，strategy_detail：抽奖策略的具体明细配置
- 奖品配置，award：用于配置具体可以得到的奖品
- 用户参与活动记录表，user_take_activity：每个用户参与活动都会记录下他的参与信息，时间、次数
- 用户活动参与次数表，user_take_activity_count：用于记录当前参与了多少次
- 用户策略计算结果表，user_strategy_export_001~004：最终策略结果的一个记录，也就是奖品中奖信息的内容

> 策略表strategy不依赖于活动表activity，即策略表中不存在跟活动相关的字段，但活动表中存在策略id字段，实现活动的策略可配置。



## 策略模式
```
策略模式（Strategy Pattern）和工厂模式（Factory Pattern）是两种常见的设计模式，它们的主要区别在于解决的问题和实现方式：

1. **解决的问题**：
   - 策略模式主要解决的是在运行时根据不同的情况选择不同的算法或策略。它将算法封装成独立的对象，使得算法可以相互替换，而且可以独立于客户端而变化。
   - 工厂模式主要解决的是创建对象的问题。它提供了一个创建对象的接口，但将具体创建对象的逻辑延迟到子类中去实现，从而使客户端代码与具体创建的对象类型解耦。

2. **实现方式**：
   - 策略模式通常包含一个策略接口和多个具体策略类，客户端根据具体情况选择不同的策略类进行使用。
   - 工厂模式通常包含一个工厂接口和多个具体工厂类，每个具体工厂类负责创建一类对象，客户端通过工厂接口获取具体的工厂类，并使用工厂类创建对象。

3. **用途**：
   - 策略模式适用于需要在运行时根据不同情况切换算法或策略的场景，例如排序算法、支付方式等。
   - 工厂模式适用于需要根据不同情况创建不同类型对象的场景，例如数据库连接、日志记录器等。

总的来说，策略模式强调的是算法的选择和切换，而工厂模式强调的是对象的创建。在实际应用中，它们常常结合使用，工厂模式用于创建具体的策略对象。
```

* `0x61c88647`：黄金分割点`0.618` * 2^32 的结果，使用黄金分割点作为hash函数取模

## 工厂模式

## 模版模式

## 状态模式


## ID算法


## 分库分表
* 分库分表
* 分库不分表

* 水平拆分
* 垂直拆分