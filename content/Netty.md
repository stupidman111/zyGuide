# I/O
> 一般I/O分为两步：
* 等待：等待缓冲区里数据的准备，接受到的数据会先存在内核缓冲区中（page cache）
* 数据搬移：数据从内核缓冲区搬移到用户空间中

> 五种I/O模型：
* 阻塞I/O模型：调用`xxx`系统调用后，会有两个等待（这两个等待都会使线程阻塞挂起）
	* 第一个阻塞等待：等待缓冲区里数据准备好，接受到的数据会先存在内核缓冲区中；
	* 第二个阻塞等待：等待内核缓冲区里的数据拷贝到用户空间；
* 非阻塞I/O模型：调用`xxx`系统调用后，会先检查内核数据是否准备好，如果没准备后会立即返回，用户需要 不断调用 或者 间隔一段时间调用（期间可以做一会别的事情） 该系统调用去检查内核数据是否准备好；一旦某一次检查到内核数据准备好了，就会阻塞等待内核缓冲区里的数据拷贝到用户空间；
	* 多个轮询访问：多次调用`xxx`系统调用查看内核数据是否准备好；
	* 一个阻塞等待：一旦内核数据准备好，就立马阻塞等待数据从内核缓冲区拷贝到用户空间；
* 多路复用I/O模型：select / poll / epoll 都属于多路复用I/O模型，
	* select：将需要监听的socket存放到select的文件描述符集合当中，该文件描述符集合是位图形式的，大小为1024，意味着我们使用select最多可以监听1024个socket。当我们调用select的时候，会将文件描述符集合`拷贝`到内核空间，让内核来检查是否有事件发生，检查就是`遍历`文件描述符集合，当检查到有事件发生时，将对应的文件描述符标记为可读/可写。当一次遍历完，再把整个文件描述符集合`拷贝`到用户空间，用户还需要`遍历`找到可读/可写的socket。
		* 两次拷贝：
			* 第一次：将文件描述符集合拷贝到内核空间，交给内核监听事件；
			* 第二次：将文件描述符集合拷贝到用户空间，交给用户处理事件；
		* 两次遍历：
			* 第一次：内核会以遍历文件描述符集合的方式，检查是否有事件发生；
			* 第二次：用户需要遍历文件描述符集合找到内核标记了发生事件的socket；
	* poll：不再使用位图作为文件描述符集合，使用链表组织的动态数组来维护，但同样还是需要扫描，
	* epoll：使用`epoll_create`创建epoll对象，调用`epoll_ctl`将需要监听的socket交给epoll来监听，最后调用`epoll_wait`等待数据。epoll在内核中维护红黑树来保存交给epoll监听的socket，并维护一个链表来记录就绪事件，所有事件发生了的socket都会加入到该链表当中，当用户调用epool_wait时，内核中的就绪事件socket链表会拷贝到用户空间，不再需要扫描的方式来确定那个文件描述符发生了事件。
* 信号驱动I/O模型：
* 异步I/O模型：