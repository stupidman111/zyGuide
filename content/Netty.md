# I/O
> 一般I/O分为两步：
* 等待：等待缓冲区里数据的准备，接受到的数据会先存在内核缓冲区中（page cache）
* 数据搬移：数据从内核缓冲区搬移到用户空间中

> 五种I/O模型：
* 阻塞I/O模型：调用`xxx`系统调用后，会有两个等待（这两个等待都会使线程阻塞挂起）
	* 第一个阻塞等待：等待缓冲区里数据准备好，接受到的数据会先存在内核缓冲区中；
	* 第二个阻塞等待：等待内核缓冲区里的数据拷贝到用户空间；
* 非阻塞I/O模型：调用`xxx`系统调用后，会先检查内核数据是否准备好，如果没准备后会立即返回，用户需要 不断调用 或者 间隔一段时间调用（期间可以做一会别的事情） 该系统调用去检查内核数据是否准备好；一旦某一次检查到内核数据准备好了，就会阻塞等待内核缓冲区里的数据拷贝到用户空间；
	* 多个轮询访问：多次调用`xxx`系统调用查看内核数据是否准备好；
	* 一个阻塞等待：一旦内核数据准备好，就立马阻塞等待数据从内核缓冲区拷贝到用户空间；
* 多路复用I/O模型：select / poll / epoll 都属于多路复用I/O模型，
	* select：将需要监听的socket存放到select的文件描述符集合当中，该文件描述符集合是位图形式的，大小为1024，意味着我们使用select最多可以监听1024个socket。当我们调用select的时候，会将文件描述符集合`拷贝`到内核空间，让内核来检查是否有事件发生，检查就是`遍历`文件描述符集合，当检查到有事件发生时，将对应的文件描述符标记为可读/可写。当一次遍历完，再把整个文件描述符集合`拷贝`到用户空间，用户还需要`遍历`找到可读/可写的socket。
		* 两次拷贝：
			* 第一次：将文件描述符集合拷贝到内核空间，交给内核监听事件；
			* 第二次：将文件描述符集合拷贝到用户空间，交给用户处理事件；
		* 两次遍历：
			* 第一次：内核会以遍历文件描述符集合的方式，检查是否有事件发生；
			* 第二次：用户需要遍历文件描述符集合找到内核标记了发生事件的socket；
	* poll：不再使用位图作为文件描述符集合，使用链表组织的动态数组来维护，但同样还是需要扫描，
	* epoll：使用`epoll_create`创建epoll对象，调用`epoll_ctl`将需要监听的socket交给epoll来监听，最后调用`epoll_wait`等待数据。epoll在内核中维护红黑树来保存交给epoll监听的socket，并维护一个链表来记录就绪事件，所有事件发生了的socket都会加入到该链表当中，当用户调用epool_wait时，内核中的就绪事件socket链表会拷贝到用户空间，不再需要扫描的方式来确定那个文件描述符发生了事件。
	* 多路复用I/O模型在一次系统调用select/poll/epoll后，仍然需要阻塞，但能够监听到多个socket的数据是否准备好，从每个socket中读取数据时，还是会阻塞一次；
		* 第一个阻塞等待：调用select/poll/epoll同时检查多个socket的内核数据是否准备好；
		* 接着n个阻塞等待：对select/poll/epoll返回的n个准备好数据的socket，每一个都需要调用系统调用将他们从内核缓冲区读取到用户空间中。
* 信号驱动I/O模型：线程先向内核注册一个信号处理函数，然后用户线程返回不阻塞，当内核数据准备好时向线程发送一个信号，线程在对应的信号处理函数中调用I/O（阻塞）读取数据，即将数据从内核拷贝到用户空间
	* 一个阻塞等待：线程接受到信号后执行信号处理函数调用I/O阻塞读取数据。
* 异步I/O模型：线程调用`xxx`系统调用后立即返回，内核将`准备内核数据`、`内核数据拷贝到用户空间`这两个操作都完成后再发送信号给线程，线程执行自定义的信号处理函数。